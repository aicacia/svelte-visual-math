import { SvelteComponent, init, safe_not_equal, flush, assign, create_component, mount_component, get_spread_update, get_spread_object, transition_in, transition_out, destroy_component, compute_rest_props, exclude_internal_props } from 'svelte/internal';
import { vec2 } from 'gl-matrix';
import Ellipse from './Ellipse.svelte.js';

/* src/Circle.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let ellipse;
	let current;

	const ellipse_spread_levels = [
		{ center: /*center*/ ctx[0] },
		{ radius: /*ellipseRadius*/ ctx[7] },
		{ angle: /*angle*/ ctx[1] },
		{ strokeStyle: /*strokeStyle*/ ctx[2] },
		{ strokeOpacity: /*strokeOpacity*/ ctx[3] },
		{ weight: /*weight*/ ctx[4] },
		{ color: /*color*/ ctx[5] },
		{ fillOpacity: /*fillOpacity*/ ctx[6] },
		/*$$restProps*/ ctx[8]
	];

	let ellipse_props = {};

	for (let i = 0; i < ellipse_spread_levels.length; i += 1) {
		ellipse_props = assign(ellipse_props, ellipse_spread_levels[i]);
	}

	ellipse = new Ellipse({ props: ellipse_props });

	return {
		c() {
			create_component(ellipse.$$.fragment);
		},
		m(target, anchor) {
			mount_component(ellipse, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const ellipse_changes = (dirty & /*center, ellipseRadius, angle, strokeStyle, strokeOpacity, weight, color, fillOpacity, $$restProps*/ 511)
			? get_spread_update(ellipse_spread_levels, [
					dirty & /*center*/ 1 && { center: /*center*/ ctx[0] },
					dirty & /*ellipseRadius*/ 128 && { radius: /*ellipseRadius*/ ctx[7] },
					dirty & /*angle*/ 2 && { angle: /*angle*/ ctx[1] },
					dirty & /*strokeStyle*/ 4 && { strokeStyle: /*strokeStyle*/ ctx[2] },
					dirty & /*strokeOpacity*/ 8 && { strokeOpacity: /*strokeOpacity*/ ctx[3] },
					dirty & /*weight*/ 16 && { weight: /*weight*/ ctx[4] },
					dirty & /*color*/ 32 && { color: /*color*/ ctx[5] },
					dirty & /*fillOpacity*/ 64 && { fillOpacity: /*fillOpacity*/ ctx[6] },
					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
				])
			: {};

			ellipse.$set(ellipse_changes);
		},
		i(local) {
			if (current) return;
			transition_in(ellipse.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(ellipse.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(ellipse, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"center","radius","angle","strokeStyle","strokeOpacity","weight","color","fillOpacity"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { center = vec2.fromValues(0, 0) } = $$props;
	let { radius = 1 } = $$props;
	let { angle = 0 } = $$props;
	let { strokeStyle = "solid" } = $$props;
	let { strokeOpacity = 1.0 } = $$props;
	let { weight = 2 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { fillOpacity = 0.15 } = $$props;
	let ellipseRadius = vec2.fromValues(radius, radius);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('center' in $$new_props) $$invalidate(0, center = $$new_props.center);
		if ('radius' in $$new_props) $$invalidate(9, radius = $$new_props.radius);
		if ('angle' in $$new_props) $$invalidate(1, angle = $$new_props.angle);
		if ('strokeStyle' in $$new_props) $$invalidate(2, strokeStyle = $$new_props.strokeStyle);
		if ('strokeOpacity' in $$new_props) $$invalidate(3, strokeOpacity = $$new_props.strokeOpacity);
		if ('weight' in $$new_props) $$invalidate(4, weight = $$new_props.weight);
		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ('fillOpacity' in $$new_props) $$invalidate(6, fillOpacity = $$new_props.fillOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ellipseRadius, radius*/ 640) {
			$$invalidate(7, ellipseRadius = vec2.set(ellipseRadius, radius, radius));
		}
	};

	return [
		center,
		angle,
		strokeStyle,
		strokeOpacity,
		weight,
		color,
		fillOpacity,
		ellipseRadius,
		$$restProps,
		radius
	];
}

class Circle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			center: 0,
			radius: 9,
			angle: 1,
			strokeStyle: 2,
			strokeOpacity: 3,
			weight: 4,
			color: 5,
			fillOpacity: 6
		});
	}

	get center() {
		return this.$$.ctx[0];
	}

	set center(center) {
		this.$$set({ center });
		flush();
	}

	get radius() {
		return this.$$.ctx[9];
	}

	set radius(radius) {
		this.$$set({ radius });
		flush();
	}

	get angle() {
		return this.$$.ctx[1];
	}

	set angle(angle) {
		this.$$set({ angle });
		flush();
	}

	get strokeStyle() {
		return this.$$.ctx[2];
	}

	set strokeStyle(strokeStyle) {
		this.$$set({ strokeStyle });
		flush();
	}

	get strokeOpacity() {
		return this.$$.ctx[3];
	}

	set strokeOpacity(strokeOpacity) {
		this.$$set({ strokeOpacity });
		flush();
	}

	get weight() {
		return this.$$.ctx[4];
	}

	set weight(weight) {
		this.$$set({ weight });
		flush();
	}

	get color() {
		return this.$$.ctx[5];
	}

	set color(color) {
		this.$$set({ color });
		flush();
	}

	get fillOpacity() {
		return this.$$.ctx[6];
	}

	set fillOpacity(fillOpacity) {
		this.$$set({ fillOpacity });
		flush();
	}
}

export { Circle as default };
//# sourceMappingURL=Circle.svelte.js.map
