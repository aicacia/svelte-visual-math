import { SvelteComponent, init, safe_not_equal, flush, svg_element, attr, toggle_class, insert, append, noop, detach, component_subscribe, binding_callbacks } from 'svelte/internal';
import { DragGesture } from '@use-gesture/vanilla';
import { vec2, mat2d } from 'gl-matrix';
import { onMount } from 'svelte';
import { getScaleContext } from './math.js';

/* src/MovablePoint.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let g;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;

	return {
		c() {
			g = svg_element("g");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]));
			attr(circle0, "cy", circle0_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]));
			attr(circle0, "r", 30);
			attr(circle0, "fill", "transparent");
			attr(circle1, "cx", circle1_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]));
			attr(circle1, "cy", circle1_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]));
			attr(circle1, "r", 6);
			attr(circle1, "fill", /*color*/ ctx[0]);
			attr(circle1, "stroke", /*color*/ ctx[0]);
			attr(circle1, "stroke-opacity", 0.25);
			attr(circle1, "tabindex", 0);
			toggle_class(circle1, "draggable", /*dragging*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, g, anchor);
			append(g, circle0);
			append(g, circle1);
			/*g_binding*/ ctx[15](g);
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaleX, display*/ 34 && circle0_cx_value !== (circle0_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]))) {
				attr(circle0, "cx", circle0_cx_value);
			}

			if (dirty & /*scaleY, display*/ 18 && circle0_cy_value !== (circle0_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]))) {
				attr(circle0, "cy", circle0_cy_value);
			}

			if (dirty & /*scaleX, display*/ 34 && circle1_cx_value !== (circle1_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]))) {
				attr(circle1, "cx", circle1_cx_value);
			}

			if (dirty & /*scaleY, display*/ 18 && circle1_cy_value !== (circle1_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]))) {
				attr(circle1, "cy", circle1_cy_value);
			}

			if (dirty & /*color*/ 1) {
				attr(circle1, "fill", /*color*/ ctx[0]);
			}

			if (dirty & /*color*/ 1) {
				attr(circle1, "stroke", /*color*/ ctx[0]);
			}

			if (dirty & /*dragging*/ 8) {
				toggle_class(circle1, "draggable", /*dragging*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(g);
			/*g_binding*/ ctx[15](null);
		}
	};
}

const VEC2_0 = vec2.create();

function instance($$self, $$props, $$invalidate) {
	let scaleX;
	let scaleY;
	let inversePixelMatrix;
	let onDrag;
	let $scaleContext;
	let { point = vec2.create() } = $$props;
	let { color = "var(--visual-math-blue)" } = $$props;
	let { transform = mat2d.create() } = $$props;
	let { constrain = undefined } = $$props;
	let intialPoint = vec2.fromValues(point[0], point[1]);
	let constraintFunction = point => point;
	point = constraintFunction(point);
	let scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(14, $scaleContext = value));
	let display = vec2.create();
	let inverseTransform = mat2d.create();
	let element;
	let startPoint = vec2.create();
	let dragging = false;

	onMount(() => {
		const dragGesture = new DragGesture(element, onDrag);

		return () => {
			dragGesture.destroy();
		};
	});

	function g_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$props => {
		if ('point' in $$props) $$invalidate(7, point = $$props.point);
		if ('color' in $$props) $$invalidate(0, color = $$props.color);
		if ('transform' in $$props) $$invalidate(8, transform = $$props.transform);
		if ('constrain' in $$props) $$invalidate(9, constrain = $$props.constrain);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*constrain*/ 512) {
			if (constrain === "horizontal") {
				$$invalidate(10, constraintFunction = ([x, _y]) => [x, intialPoint[1]]);
			} else if (constrain === "vertical") {
				$$invalidate(10, constraintFunction = ([_x, y]) => [intialPoint[0], y]);
			} else if (typeof constrain === "function") {
				$$invalidate(10, constraintFunction = constrain);
			}
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(5, scaleX = $scaleContext.scaleX);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(4, scaleY = $scaleContext.scaleY);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(13, inversePixelMatrix = $scaleContext.inversePixelMatrix);
		}

		if ($$self.$$.dirty & /*inverseTransform, transform*/ 2304) {
			$$invalidate(11, inverseTransform = mat2d.invert(inverseTransform, transform));
		}

		if ($$self.$$.dirty & /*inversePixelMatrix, startPoint, point, transform, inverseTransform, constraintFunction*/ 15744) {
			onDrag = state => {
				var _a;

				(_a = state.event) === null || _a === void 0
				? void 0
				: _a.stopPropagation();

				$$invalidate(3, dragging = state.down);
				const movement = vec2.transformMat2d(VEC2_0, state.movement, inversePixelMatrix);

				if (state.first) {
					$$invalidate(12, startPoint = vec2.transformMat2d(startPoint, point, transform));
				}

				vec2.add(point, startPoint, movement);
				vec2.transformMat2d(point, point, inverseTransform);
				$$invalidate(7, point = constraintFunction(point));
			};
		}

		if ($$self.$$.dirty & /*display, point, transform*/ 386) {
			$$invalidate(1, display = vec2.transformMat2d(display, point, transform));
		}
	};

	return [
		color,
		display,
		element,
		dragging,
		scaleY,
		scaleX,
		scaleContext,
		point,
		transform,
		constrain,
		constraintFunction,
		inverseTransform,
		startPoint,
		inversePixelMatrix,
		$scaleContext,
		g_binding
	];
}

class MovablePoint extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			point: 7,
			color: 0,
			transform: 8,
			constrain: 9
		});
	}

	get point() {
		return this.$$.ctx[7];
	}

	set point(point) {
		this.$$set({ point });
		flush();
	}

	get color() {
		return this.$$.ctx[0];
	}

	set color(color) {
		this.$$set({ color });
		flush();
	}

	get transform() {
		return this.$$.ctx[8];
	}

	set transform(transform) {
		this.$$set({ transform });
		flush();
	}

	get constrain() {
		return this.$$.ctx[9];
	}

	set constrain(constrain) {
		this.$$set({ constrain });
		flush();
	}
}

export { MovablePoint as default };
//# sourceMappingURL=MovablePoint.svelte.js.map
