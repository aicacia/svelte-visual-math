import { SvelteComponent, init, safe_not_equal, flush, assign, svg_element, set_svg_attributes, insert, get_spread_update, noop, detach, compute_rest_props, component_subscribe, exclude_internal_props } from 'svelte/internal';
import { vec2 } from 'gl-matrix';
import { getScaleContext } from './math.js';

/* src/Point.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let circle_style_value;

	let circle_levels = [
		{
			cx: circle_cx_value = /*scaleX*/ ctx[4](/*point*/ ctx[0][0])
		},
		{
			cy: circle_cy_value = /*scaleY*/ ctx[3](/*point*/ ctx[0][1])
		},
		{ r: circle_r_value = 6 },
		/*$$restProps*/ ctx[6],
		{
			style: circle_style_value = `fill: ${/*color*/ ctx[1]}; opacity: ${/*opacity*/ ctx[2]}; ${/*$$restProps*/ ctx[6].style}`
		}
	];

	let circle_data = {};

	for (let i = 0; i < circle_levels.length; i += 1) {
		circle_data = assign(circle_data, circle_levels[i]);
	}

	return {
		c() {
			circle = svg_element("circle");
			set_svg_attributes(circle, circle_data);
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(circle, circle_data = get_spread_update(circle_levels, [
				dirty & /*scaleX, point*/ 17 && circle_cx_value !== (circle_cx_value = /*scaleX*/ ctx[4](/*point*/ ctx[0][0])) && { cx: circle_cx_value },
				dirty & /*scaleY, point*/ 9 && circle_cy_value !== (circle_cy_value = /*scaleY*/ ctx[3](/*point*/ ctx[0][1])) && { cy: circle_cy_value },
				{ r: circle_r_value },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*color, opacity, $$restProps*/ 70 && circle_style_value !== (circle_style_value = `fill: ${/*color*/ ctx[1]}; opacity: ${/*opacity*/ ctx[2]}; ${/*$$restProps*/ ctx[6].style}`) && { style: circle_style_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let scaleX;
	let scaleY;
	const omit_props_names = ["point","color","opacity"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $scaleContext;
	let { point = vec2.create() } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { opacity = 1 } = $$props;
	const scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(7, $scaleContext = value));

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('point' in $$new_props) $$invalidate(0, point = $$new_props.point);
		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
		if ('opacity' in $$new_props) $$invalidate(2, opacity = $$new_props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 128) {
			$$invalidate(4, scaleX = $scaleContext.scaleX);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 128) {
			$$invalidate(3, scaleY = $scaleContext.scaleY);
		}
	};

	return [
		point,
		color,
		opacity,
		scaleY,
		scaleX,
		scaleContext,
		$$restProps,
		$scaleContext
	];
}

class Point extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { point: 0, color: 1, opacity: 2 });
	}

	get point() {
		return this.$$.ctx[0];
	}

	set point(point) {
		this.$$set({ point });
		flush();
	}

	get color() {
		return this.$$.ctx[1];
	}

	set color(color) {
		this.$$set({ color });
		flush();
	}

	get opacity() {
		return this.$$.ctx[2];
	}

	set opacity(opacity) {
		this.$$set({ opacity });
		flush();
	}
}

export { Point as default };
//# sourceMappingURL=Point.svelte.js.map
