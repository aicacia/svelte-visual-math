import { SvelteComponent, init, safe_not_equal, flush, svg_element, attr, insert, noop, detach, component_subscribe } from 'svelte/internal';
import { vec2 } from 'gl-matrix';
import { getScaleContext } from './math.js';

/* src/ThroughPoints.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let line;
	let line_x__value;
	let line_y__value;
	let line_x__value_1;
	let line_y__value_1;
	let line_style_value;
	let line_stroke_dasharray_value;

	return {
		c() {
			line = svg_element("line");
			attr(line, "x1", line_x__value = /*scaledPoint1*/ ctx[4][0]);
			attr(line, "y1", line_y__value = /*scaledPoint1*/ ctx[4][1]);
			attr(line, "x2", line_x__value_1 = /*scaledPoint2*/ ctx[5][0]);
			attr(line, "y2", line_y__value_1 = /*scaledPoint2*/ ctx[5][1]);
			attr(line, "style", line_style_value = `stroke: ${/*color*/ ctx[0]}`);
			attr(line, "stroke-width", /*weight*/ ctx[2]);
			attr(line, "opacity", /*opacity*/ ctx[3]);
			attr(line, "stroke-dasharray", line_stroke_dasharray_value = /*style*/ ctx[1] === "dashed" ? "4,3" : undefined);
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaledPoint1*/ 16 && line_x__value !== (line_x__value = /*scaledPoint1*/ ctx[4][0])) {
				attr(line, "x1", line_x__value);
			}

			if (dirty & /*scaledPoint1*/ 16 && line_y__value !== (line_y__value = /*scaledPoint1*/ ctx[4][1])) {
				attr(line, "y1", line_y__value);
			}

			if (dirty & /*scaledPoint2*/ 32 && line_x__value_1 !== (line_x__value_1 = /*scaledPoint2*/ ctx[5][0])) {
				attr(line, "x2", line_x__value_1);
			}

			if (dirty & /*scaledPoint2*/ 32 && line_y__value_1 !== (line_y__value_1 = /*scaledPoint2*/ ctx[5][1])) {
				attr(line, "y2", line_y__value_1);
			}

			if (dirty & /*color*/ 1 && line_style_value !== (line_style_value = `stroke: ${/*color*/ ctx[0]}`)) {
				attr(line, "style", line_style_value);
			}

			if (dirty & /*weight*/ 4) {
				attr(line, "stroke-width", /*weight*/ ctx[2]);
			}

			if (dirty & /*opacity*/ 8) {
				attr(line, "opacity", /*opacity*/ ctx[3]);
			}

			if (dirty & /*style*/ 2 && line_stroke_dasharray_value !== (line_stroke_dasharray_value = /*style*/ ctx[1] === "dashed" ? "4,3" : undefined)) {
				attr(line, "stroke-dasharray", line_stroke_dasharray_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

const VEC2_0 = vec2.create();

function instance($$self, $$props, $$invalidate) {
	let pixelMatrix;
	let $scaleContext;
	let { point1 = vec2.create() } = $$props;
	let { point2 = vec2.create() } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { style = "solid" } = $$props;
	let { weight = 2 } = $$props;
	let { opacity = 1 } = $$props;
	const scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(11, $scaleContext = value));
	let segment = vec2.create();
	let scaledPoint1 = vec2.create();
	let scaledPoint2 = vec2.create();

	$$self.$$set = $$props => {
		if ('point1' in $$props) $$invalidate(7, point1 = $$props.point1);
		if ('point2' in $$props) $$invalidate(8, point2 = $$props.point2);
		if ('color' in $$props) $$invalidate(0, color = $$props.color);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('weight' in $$props) $$invalidate(2, weight = $$props.weight);
		if ('opacity' in $$props) $$invalidate(3, opacity = $$props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 2048) {
			$$invalidate(10, pixelMatrix = $scaleContext.pixelMatrix);
		}

		if ($$self.$$.dirty & /*segment, point2, point1*/ 896) {
			$$invalidate(9, segment = vec2.scale(segment, vec2.normalize(segment, vec2.sub(VEC2_0, point2, point1)), 100000));
		}

		if ($$self.$$.dirty & /*scaledPoint1, point1, segment, pixelMatrix*/ 1680) {
			$$invalidate(4, scaledPoint1 = vec2.transformMat2d(scaledPoint1, vec2.sub(VEC2_0, point1, segment), pixelMatrix));
		}

		if ($$self.$$.dirty & /*scaledPoint2, point2, segment, pixelMatrix*/ 1824) {
			$$invalidate(5, scaledPoint2 = vec2.transformMat2d(scaledPoint2, vec2.add(VEC2_0, point2, segment), pixelMatrix));
		}
	};

	return [
		color,
		style,
		weight,
		opacity,
		scaledPoint1,
		scaledPoint2,
		scaleContext,
		point1,
		point2,
		segment,
		pixelMatrix,
		$scaleContext
	];
}

class ThroughPoints extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			point1: 7,
			point2: 8,
			color: 0,
			style: 1,
			weight: 2,
			opacity: 3
		});
	}

	get point1() {
		return this.$$.ctx[7];
	}

	set point1(point1) {
		this.$$set({ point1 });
		flush();
	}

	get point2() {
		return this.$$.ctx[8];
	}

	set point2(point2) {
		this.$$set({ point2 });
		flush();
	}

	get color() {
		return this.$$.ctx[0];
	}

	set color(color) {
		this.$$set({ color });
		flush();
	}

	get style() {
		return this.$$.ctx[1];
	}

	set style(style) {
		this.$$set({ style });
		flush();
	}

	get weight() {
		return this.$$.ctx[2];
	}

	set weight(weight) {
		this.$$set({ weight });
		flush();
	}

	get opacity() {
		return this.$$.ctx[3];
	}

	set opacity(opacity) {
		this.$$set({ opacity });
		flush();
	}
}

export { ThroughPoints as default };
//# sourceMappingURL=ThroughPoints.svelte.js.map
