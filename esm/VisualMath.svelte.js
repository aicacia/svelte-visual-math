import { SvelteComponent, init, safe_not_equal, flush, append_styles, create_slot, element, svg_element, attr, add_render_callback, insert, append, add_resize_listener, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, detach, binding_callbacks } from 'svelte/internal';
import { DragGesture, WheelGesture } from '@use-gesture/vanilla';
import { range } from '@aicacia/core';
import { vec2, mat2d } from 'gl-matrix';
import { setPanesContext, setCoordinateContext, setScaleContext, setMapContext } from './math.js';
import { writable } from 'svelte/store';
import { onMount } from 'svelte';

/* src/VisualMath.svelte generated by Svelte v3.42.4 */

function add_css(target) {
	append_styles(target, "svelte-5trppw", ".visual-math.svelte-5trppw{display:block;background:var(--visual-math-bg);overflow:hidden;user-select:none;font-family:sans-serif;font-variant-numeric:tabular-nums;--visual-math-bg:#f1f1f1;--visual-math-fg:black;--visual-math-origin-color:var(--visual-math-fg);--visual-math-line-color:#555;--grid-line-subdivision-color:#222;--visual-math-red:#f10000;--visual-math-orange:#f18100;--visual-math-yellow:#f1f100;--visual-math-green:#00f181;--visual-math-blue:#0000f1;--visual-math-indigo:#8100f1;--visual-math-violet:#8100f1;--visual-math-pink:#f18181}");
}

function create_fragment(ctx) {
	let div;
	let svg;
	let svg_viewBox_value;
	let svg_style_value;
	let div_style_value;
	let div_resize_listener;
	let current;
	const default_slot_template = /*#slots*/ ctx[38].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			attr(svg, "width", /*actualWidth*/ ctx[2]);
			attr(svg, "height", /*actualHeight*/ ctx[3]);
			attr(svg, "viewBox", svg_viewBox_value = `${-/*mapX*/ ctx[5](0)} ${-/*mapY*/ ctx[4](0)} ${/*actualWidth*/ ctx[2]} ${/*actualHeight*/ ctx[3]}`);
			attr(svg, "preserveAspectRatio", "xMidYMin");
			attr(svg, "style", svg_style_value = `width: ${/*width*/ ctx[0]}; touch-action: ${/*pan*/ ctx[1] ? "none" : "auto"};`);
			attr(div, "class", "visual-math svelte-5trppw");
			attr(div, "style", div_style_value = `width: ${/*desiredCssWidth*/ ctx[8]}; height: ${/*desiredCssHeight*/ ctx[7]}`);
			add_render_callback(() => /*div_elementresize_handler*/ ctx[40].call(div));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			/*div_binding*/ ctx[39](div);
			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[40].bind(div));
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*actualWidth*/ 4) {
				attr(svg, "width", /*actualWidth*/ ctx[2]);
			}

			if (!current || dirty[0] & /*actualHeight*/ 8) {
				attr(svg, "height", /*actualHeight*/ ctx[3]);
			}

			if (!current || dirty[0] & /*mapX, mapY, actualWidth, actualHeight*/ 60 && svg_viewBox_value !== (svg_viewBox_value = `${-/*mapX*/ ctx[5](0)} ${-/*mapY*/ ctx[4](0)} ${/*actualWidth*/ ctx[2]} ${/*actualHeight*/ ctx[3]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			if (!current || dirty[0] & /*width, pan*/ 3 && svg_style_value !== (svg_style_value = `width: ${/*width*/ ctx[0]}; touch-action: ${/*pan*/ ctx[1] ? "none" : "auto"};`)) {
				attr(svg, "style", svg_style_value);
			}

			if (!current || dirty[0] & /*desiredCssWidth, desiredCssHeight*/ 384 && div_style_value !== (div_style_value = `width: ${/*desiredCssWidth*/ ctx[8]}; height: ${/*desiredCssHeight*/ ctx[7]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[39](null);
			div_resize_listener();
		}
	};
}

const VEC2_0 = vec2.create();

function getMouseWheelDirection(e) {
	if (typeof e.detail == "number" && e.detail !== 0) {
		if (e.detail > 0) {
			return -1;
		} else if (e.detail < 0) {
			return 1;
		}
	} else if (typeof e.wheelDelta === "number") {
		if (e.wheelDelta < 0) {
			return -1;
		} else if (e.wheelDelta > 0) {
			return 1;
		}
	}

	return undefined;
}

let base = 2;

function instance($$self, $$props, $$invalidate) {
	let desiredCssWidth;
	let desiredCssHeight;
	let mapX;
	let mapY;
	let scaleX;
	let scaleY;
	let unscaleX;
	let unscaleY;
	let cssScale;
	let xSpan;
	let xStep;
	let xLowerBound;
	let xUpperBound;
	let ySpan;
	let yStep;
	let yLowerBound;
	let yUpperBound;
	let onDrag;
	let onMouseWheel;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { width = 500 } = $$props;
	let { height = 500 } = $$props;
	let { pan = true } = $$props;
	let { zoom = true } = $$props;
	let { xAxisExtent = vec2.fromValues(-5.5, 5.5) } = $$props;
	let { yAxisExtent = vec2.fromValues(-5.5, 5.5) } = $$props;
	let actualWidth = typeof width === "number" ? width : 500;
	let actualHeight = typeof height === "number" ? height : 500;
	let zoomAmount = Math.min(xAxisExtent[1] - xAxisExtent[0], yAxisExtent[1] - yAxisExtent[0]);
	let offset = vec2.fromValues(0, 0);
	let min = vec2.fromValues(xAxisExtent[0], yAxisExtent[0]);
	let max = vec2.fromValues(xAxisExtent[1], yAxisExtent[1]);
	let span = vec2.create();
	let pixelMatrix = mat2d.create();
	let inversePixelMatrix = mat2d.create();
	let xPanes = [];
	let yPanes = [];
	let xPaneRange = vec2.create();
	let yPaneRange = vec2.create();
	let panesContext = writable({ xPanes, yPanes, xPaneRange, yPaneRange });
	setPanesContext(panesContext);

	let coordinateContext = writable({
		min,
		max,
		width: actualWidth,
		height: actualHeight
	});

	setCoordinateContext(coordinateContext);

	let scaleContext = writable({
		zoomAmount,
		scaleX,
		scaleY,
		span,
		pixelMatrix,
		inversePixelMatrix,
		cssScale
	});

	setScaleContext(scaleContext);
	let mapContext = writable({ mapX, mapY });
	setMapContext(mapContext);
	let element;

	onMount(() => {
		const dragGesture = new DragGesture(element, onDrag),
			wheelGesture = new WheelGesture(element, onMouseWheel);

		return () => {
			dragGesture.destroy();
			wheelGesture.destroy();
		};
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	function div_elementresize_handler() {
		actualWidth = this.offsetWidth;
		actualHeight = this.offsetHeight;
		$$invalidate(2, actualWidth);
		$$invalidate(3, actualHeight);
	}

	$$self.$$set = $$props => {
		if ('width' in $$props) $$invalidate(0, width = $$props.width);
		if ('height' in $$props) $$invalidate(11, height = $$props.height);
		if ('pan' in $$props) $$invalidate(1, pan = $$props.pan);
		if ('zoom' in $$props) $$invalidate(12, zoom = $$props.zoom);
		if ('xAxisExtent' in $$props) $$invalidate(9, xAxisExtent = $$props.xAxisExtent);
		if ('yAxisExtent' in $$props) $$invalidate(10, yAxisExtent = $$props.yAxisExtent);
		if ('$$scope' in $$props) $$invalidate(37, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*width*/ 1) {
			$$invalidate(8, desiredCssWidth = width === "auto" ? "100%" : `${width}px`);
		}

		if ($$self.$$.dirty[0] & /*height*/ 2048) {
			$$invalidate(7, desiredCssHeight = height === "auto" ? "100%" : `${height}px`);
		}

		if ($$self.$$.dirty[0] & /*zoom, zoomAmount, xAxisExtent, yAxisExtent*/ 13824) {
			onMouseWheel = state => {
				if (!zoom || state.last) {
					return;
				}

				const wheelDirection = getMouseWheelDirection(state.event);

				if (wheelDirection && (zoomAmount > 3 || wheelDirection < 0)) {
					$$invalidate(9, xAxisExtent = vec2.set(xAxisExtent, xAxisExtent[0] + wheelDirection, xAxisExtent[1] - wheelDirection));
					$$invalidate(10, yAxisExtent = vec2.set(yAxisExtent, yAxisExtent[0] + wheelDirection, yAxisExtent[1] - wheelDirection));
					$$invalidate(13, zoomAmount = Math.min(xAxisExtent[1] - xAxisExtent[0], yAxisExtent[1] - yAxisExtent[0]));
				}
			};
		}

		if ($$self.$$.dirty[0] & /*actualWidth, actualHeight, zoomAmount*/ 8204) {
			{
				const aspect = actualWidth / actualHeight,
					halfZoomAmount = zoomAmount * 0.5,
					newZoomAmount = zoomAmount * aspect,
					halfNewZoomAmount = newZoomAmount * 0.5;

				$$invalidate(9, xAxisExtent[0] = -halfNewZoomAmount, xAxisExtent);
				$$invalidate(9, xAxisExtent[1] = halfNewZoomAmount, xAxisExtent);
				$$invalidate(10, yAxisExtent[0] = -halfZoomAmount, yAxisExtent);
				$$invalidate(10, yAxisExtent[1] = halfZoomAmount, yAxisExtent);
			}
		}

		if ($$self.$$.dirty[0] & /*pan, actualWidth, xAxisExtent, actualHeight, yAxisExtent*/ 1550) {
			onDrag = state => {
				if (!pan) {
					return;
				}

				$$invalidate(14, offset[0] = -state.offset[0] / actualWidth * (xAxisExtent[1] - xAxisExtent[0]), offset);
				$$invalidate(14, offset[1] = -state.offset[1] / actualHeight * (yAxisExtent[1] - yAxisExtent[0]), offset);
			};
		}

		if ($$self.$$.dirty[0] & /*min, offset, xAxisExtent, yAxisExtent*/ 50688) {
			$$invalidate(15, min = vec2.add(min, offset, vec2.set(VEC2_0, xAxisExtent[0], yAxisExtent[0])));
		}

		if ($$self.$$.dirty[0] & /*max, offset, xAxisExtent, yAxisExtent*/ 83456) {
			$$invalidate(16, max = vec2.add(max, offset, vec2.set(VEC2_0, xAxisExtent[1], yAxisExtent[1])));
		}

		if ($$self.$$.dirty[0] & /*min, max, actualWidth*/ 98308) {
			$$invalidate(5, mapX = x => (x - min[0]) / (max[0] - min[0]) * actualWidth);
		}

		if ($$self.$$.dirty[0] & /*min, max, actualHeight*/ 98312) {
			$$invalidate(4, mapY = y => (y - min[1]) / (max[1] - min[1]) * actualHeight);
		}

		if ($$self.$$.dirty[0] & /*span, max, min*/ 229376) {
			$$invalidate(17, span = vec2.sub(span, max, min));
		}

		if ($$self.$$.dirty[0] & /*span, actualWidth*/ 131076) {
			$$invalidate(26, scaleX = x => x / span[0] * actualWidth);
		}

		if ($$self.$$.dirty[0] & /*span, actualHeight*/ 131080) {
			$$invalidate(25, scaleY = y => -y / span[1] * actualHeight);
		}

		if ($$self.$$.dirty[0] & /*max, min*/ 98304) {
			$$invalidate(34, xSpan = max[0] - min[0]);
		}

		if ($$self.$$.dirty[0] & /*actualWidth*/ 4 | $$self.$$.dirty[1] & /*xSpan*/ 8) {
			$$invalidate(36, unscaleX = x => x / actualWidth * xSpan);
		}

		if ($$self.$$.dirty[0] & /*max, min*/ 98304) {
			$$invalidate(30, ySpan = max[1] - min[1]);
		}

		if ($$self.$$.dirty[0] & /*actualHeight, ySpan*/ 1073741832) {
			$$invalidate(35, unscaleY = y => -y / actualHeight * ySpan);
		}

		if ($$self.$$.dirty[0] & /*pixelMatrix, scaleX, scaleY*/ 100925440) {
			$$invalidate(18, pixelMatrix = mat2d.fromScaling(pixelMatrix, vec2.set(VEC2_0, scaleX(1), scaleY(1))));
		}

		if ($$self.$$.dirty[0] & /*inversePixelMatrix*/ 524288 | $$self.$$.dirty[1] & /*unscaleX, unscaleY*/ 48) {
			$$invalidate(19, inversePixelMatrix = mat2d.fromScaling(inversePixelMatrix, vec2.set(VEC2_0, unscaleX(1), unscaleY(1))));
		}

		if ($$self.$$.dirty[0] & /*scaleX, scaleY*/ 100663296) {
			$$invalidate(24, cssScale = `scale(${scaleX(1)} ${scaleY(1)})`);
		}

		if ($$self.$$.dirty[1] & /*xSpan*/ 8) {
			$$invalidate(33, xStep = Math.pow(base, Math.round(Math.log10(xSpan) / Math.log10(base))));
		}

		if ($$self.$$.dirty[0] & /*min*/ 32768 | $$self.$$.dirty[1] & /*xStep*/ 4) {
			$$invalidate(32, xLowerBound = Math.floor(min[0] / xStep) * xStep);
		}

		if ($$self.$$.dirty[0] & /*max*/ 65536 | $$self.$$.dirty[1] & /*xStep*/ 4) {
			$$invalidate(31, xUpperBound = Math.ceil(max[0] / xStep) * xStep);
		}

		if ($$self.$$.dirty[1] & /*xLowerBound, xUpperBound, xStep*/ 7) {
			$$invalidate(20, xPanes = range(xLowerBound, xUpperBound, xStep).iter().map(xMin => vec2.fromValues(xMin, xMin + xStep)).toArray());
		}

		if ($$self.$$.dirty[0] & /*xPaneRange*/ 4194304 | $$self.$$.dirty[1] & /*xLowerBound, xUpperBound*/ 3) {
			$$invalidate(22, xPaneRange = vec2.set(xPaneRange, xLowerBound, xUpperBound));
		}

		if ($$self.$$.dirty[0] & /*ySpan*/ 1073741824) {
			$$invalidate(29, yStep = Math.pow(base, Math.round(Math.log10(ySpan) / Math.log10(base))));
		}

		if ($$self.$$.dirty[0] & /*min, yStep*/ 536903680) {
			$$invalidate(28, yLowerBound = Math.floor(min[0] / yStep) * yStep);
		}

		if ($$self.$$.dirty[0] & /*max, yStep*/ 536936448) {
			$$invalidate(27, yUpperBound = Math.ceil(max[0] / yStep) * yStep);
		}

		if ($$self.$$.dirty[0] & /*yLowerBound, yUpperBound, yStep*/ 939524096) {
			$$invalidate(21, yPanes = range(yLowerBound, yUpperBound, yStep).iter().map(yMin => vec2.fromValues(yMin, yMin + yStep)).toArray());
		}

		if ($$self.$$.dirty[0] & /*yPaneRange, yLowerBound, yUpperBound*/ 411041792) {
			$$invalidate(23, yPaneRange = vec2.set(yPaneRange, yLowerBound, yUpperBound));
		}

		if ($$self.$$.dirty[0] & /*xPanes, yPanes, xPaneRange, yPaneRange*/ 15728640) {
			panesContext.set({ xPanes, yPanes, xPaneRange, yPaneRange });
		}

		if ($$self.$$.dirty[0] & /*min, max, actualWidth, actualHeight*/ 98316) {
			coordinateContext.set({
				min,
				max,
				width: actualWidth,
				height: actualHeight
			});
		}

		if ($$self.$$.dirty[0] & /*zoomAmount, scaleX, scaleY, span, pixelMatrix, inversePixelMatrix, cssScale*/ 118366208) {
			scaleContext.set({
				zoomAmount,
				scaleX,
				scaleY,
				span,
				pixelMatrix,
				inversePixelMatrix,
				cssScale
			});
		}

		if ($$self.$$.dirty[0] & /*mapX, mapY*/ 48) {
			mapContext.set({ mapX, mapY });
		}
	};

	return [
		width,
		pan,
		actualWidth,
		actualHeight,
		mapY,
		mapX,
		element,
		desiredCssHeight,
		desiredCssWidth,
		xAxisExtent,
		yAxisExtent,
		height,
		zoom,
		zoomAmount,
		offset,
		min,
		max,
		span,
		pixelMatrix,
		inversePixelMatrix,
		xPanes,
		yPanes,
		xPaneRange,
		yPaneRange,
		cssScale,
		scaleY,
		scaleX,
		yUpperBound,
		yLowerBound,
		yStep,
		ySpan,
		xUpperBound,
		xLowerBound,
		xStep,
		xSpan,
		unscaleY,
		unscaleX,
		$$scope,
		slots,
		div_binding,
		div_elementresize_handler
	];
}

class VisualMath extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				width: 0,
				height: 11,
				pan: 1,
				zoom: 12,
				xAxisExtent: 9,
				yAxisExtent: 10
			},
			add_css,
			[-1, -1]
		);
	}

	get width() {
		return this.$$.ctx[0];
	}

	set width(width) {
		this.$$set({ width });
		flush();
	}

	get height() {
		return this.$$.ctx[11];
	}

	set height(height) {
		this.$$set({ height });
		flush();
	}

	get pan() {
		return this.$$.ctx[1];
	}

	set pan(pan) {
		this.$$set({ pan });
		flush();
	}

	get zoom() {
		return this.$$.ctx[12];
	}

	set zoom(zoom) {
		this.$$set({ zoom });
		flush();
	}

	get xAxisExtent() {
		return this.$$.ctx[9];
	}

	set xAxisExtent(xAxisExtent) {
		this.$$set({ xAxisExtent });
		flush();
	}

	get yAxisExtent() {
		return this.$$.ctx[10];
	}

	set yAxisExtent(yAxisExtent) {
		this.$$set({ yAxisExtent });
		flush();
	}
}

export { VisualMath as default };
//# sourceMappingURL=VisualMath.svelte.js.map
