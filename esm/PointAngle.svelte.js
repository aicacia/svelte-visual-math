import { SvelteComponent, init, safe_not_equal, flush, create_component, mount_component, transition_in, transition_out, destroy_component } from 'svelte/internal';
import { vec2 } from 'gl-matrix';
import ThroughPoints from './ThroughPoints.svelte.js';

/* src/PointAngle.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let throughpoints;
	let current;

	throughpoints = new ThroughPoints({
			props: {
				point1: /*point*/ ctx[0],
				point2: /*point2*/ ctx[5],
				color: /*color*/ ctx[1],
				opacity: /*opacity*/ ctx[4],
				style: /*style*/ ctx[2],
				weight: /*weight*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(throughpoints.$$.fragment);
		},
		m(target, anchor) {
			mount_component(throughpoints, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const throughpoints_changes = {};
			if (dirty & /*point*/ 1) throughpoints_changes.point1 = /*point*/ ctx[0];
			if (dirty & /*point2*/ 32) throughpoints_changes.point2 = /*point2*/ ctx[5];
			if (dirty & /*color*/ 2) throughpoints_changes.color = /*color*/ ctx[1];
			if (dirty & /*opacity*/ 16) throughpoints_changes.opacity = /*opacity*/ ctx[4];
			if (dirty & /*style*/ 4) throughpoints_changes.style = /*style*/ ctx[2];
			if (dirty & /*weight*/ 8) throughpoints_changes.weight = /*weight*/ ctx[3];
			throughpoints.$set(throughpoints_changes);
		},
		i(local) {
			if (current) return;
			transition_in(throughpoints.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(throughpoints.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(throughpoints, detaching);
		}
	};
}

const VEC2_0 = vec2.create();
const ZERO = vec2.create();
const RIGHT = vec2.fromValues(1, 0);

function instance($$self, $$props, $$invalidate) {
	let { point = vec2.create() } = $$props;
	let { angle = 0 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { style = "solid" } = $$props;
	let { weight = 2 } = $$props;
	let { opacity = 1 } = $$props;
	let point2 = vec2.create();

	$$self.$$set = $$props => {
		if ('point' in $$props) $$invalidate(0, point = $$props.point);
		if ('angle' in $$props) $$invalidate(6, angle = $$props.angle);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('weight' in $$props) $$invalidate(3, weight = $$props.weight);
		if ('opacity' in $$props) $$invalidate(4, opacity = $$props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*point2, point, angle*/ 97) {
			$$invalidate(5, point2 = vec2.add(point2, point, vec2.rotate(VEC2_0, RIGHT, ZERO, angle)));
		}
	};

	return [point, color, style, weight, opacity, point2, angle];
}

class PointAngle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			point: 0,
			angle: 6,
			color: 1,
			style: 2,
			weight: 3,
			opacity: 4
		});
	}

	get point() {
		return this.$$.ctx[0];
	}

	set point(point) {
		this.$$set({ point });
		flush();
	}

	get angle() {
		return this.$$.ctx[6];
	}

	set angle(angle) {
		this.$$set({ angle });
		flush();
	}

	get color() {
		return this.$$.ctx[1];
	}

	set color(color) {
		this.$$set({ color });
		flush();
	}

	get style() {
		return this.$$.ctx[2];
	}

	set style(style) {
		this.$$set({ style });
		flush();
	}

	get weight() {
		return this.$$.ctx[3];
	}

	set weight(weight) {
		this.$$set({ weight });
		flush();
	}

	get opacity() {
		return this.$$.ctx[4];
	}

	set opacity(opacity) {
		this.$$set({ opacity });
		flush();
	}
}

export { PointAngle as default };
//# sourceMappingURL=PointAngle.svelte.js.map
