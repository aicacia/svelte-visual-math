{"version":3,"file":"index.js","sources":["../src/math.ts","../src/XLabels.svelte","../src/YLabels.svelte","../src/GridPattern.svelte","../src/CartesianCoordinates.svelte","../src/Ellipse.svelte","../src/Circle.svelte","../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","../node_modules/@use-gesture/core/dist/actions-0efe52f5.esm.js","../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../node_modules/@use-gesture/vanilla/dist/use-gesture-vanilla.esm.js","../src/MovablePoint.svelte","../src/Point.svelte","../src/ThroughPoints.svelte","../src/PointAngle.svelte","../src/PointSlope.svelte","../src/VisualMath.svelte"],"sourcesContent":[null,"<script lang=\"ts\">\n  import type { ILabelMaker } from \"./math\";\n  import { snappedRange, getPanesContext, getScaleContext } from \"./math\";\n\n  export let separation: number;\n  export let labelMaker: ILabelMaker | false;\n\n  let scaleContext = getScaleContext();\n  let panesContext = getPanesContext();\n\n  $: scaleX = $scaleContext.scaleX;\n  $: xPanes = $panesContext.xPanes;\n\n  $: xs = snappedRange(\n    xPanes[0][0] - separation,\n    xPanes[xPanes.length - 1][1] + separation,\n    separation\n  ).filter((x) => Math.abs(scaleX(x) - scaleX(0)) > 1);\n</script>\n\n<g>\n  {#each xs as x}\n    <text x={scaleX(x)} y={5} alignment-baseline=\"hanging\" text-anchor=\"middle\">\n      {labelMaker ? labelMaker(x) : x}\n    </text>\n  {/each}\n</g>\n\n<style>\n  g {\n    paint-order: stroke;\n    stroke-width: 3px;\n    stroke: var(--visual-math-line-color);\n    stroke-opacity: 0.75;\n  }\n</style>\n","<script lang=\"ts\">\n  import type { ILabelMaker } from \"./math\";\n  import { snappedRange, getPanesContext, getScaleContext } from \"./math\";\n\n  export let separation: number;\n  export let labelMaker: ILabelMaker | false;\n\n  let scaleContext = getScaleContext();\n  let panesContext = getPanesContext();\n\n  $: scaleY = $scaleContext.scaleY;\n  $: yPanes = $panesContext.yPanes;\n\n  $: ys = snappedRange(\n    yPanes[0][0] - separation,\n    yPanes[yPanes.length - 1][1] + separation,\n    separation\n  ).filter((y) => Math.abs(scaleY(y) - scaleY(0)) > 1);\n</script>\n\n<g>\n  {#each ys as y}\n    <text x={5} y={scaleY(y)} alignment-baseline=\"central\">\n      {labelMaker ? labelMaker(y) : y}\n    </text>\n  {/each}\n</g>\n\n<style>\n  g {\n    paint-order: stroke;\n    stroke-width: 3px;\n    stroke: var(--visual-math-line-color);\n    stroke-opacity: 0.75;\n  }\n</style>\n","<script lang=\"ts\">\n  import { range } from \"@aicacia/core\";\n  import { getScaleContext } from \"./math\";\n\n  export let id: string;\n  export let xLines: number | false = 1;\n  export let yLines: number | false = 1;\n  export let xSubdivisions: number | false = 1;\n  export let ySubdivisions: number | false = 1;\n\n  let context = getScaleContext();\n  $: scaleX = $context.scaleX;\n  $: scaleY = $context.scaleY;\n\n  $: width = scaleX(xLines || 1);\n  $: height = -scaleY(yLines || 1);\n\n  let xs: number[] = [];\n  $: if (xSubdivisions && xSubdivisions > 1) {\n    const pixelXDistance = width / xSubdivisions;\n    xs = range(0, width + pixelXDistance * 1.1, pixelXDistance)\n      .iter()\n      .toArray();\n  }\n\n  let ys: number[] = [];\n  $: if (ySubdivisions && ySubdivisions > 1) {\n    const pixelYDistance = height / ySubdivisions;\n    ys = range(0, height + pixelYDistance * 1.1, pixelYDistance)\n      .iter()\n      .toArray();\n  }\n</script>\n\n<pattern {id} x=\"0\" y=\"0\" {width} {height} patternUnits=\"userSpaceOnUse\">\n  {#each xs as x}\n    <line\n      x1={x}\n      y1={0}\n      x2={x}\n      y2={height}\n      style={`stroke: var(--grid-line-subdivision-color)`}\n    />\n  {/each}\n  {#each ys as y}\n    <line\n      y1={y}\n      x1={0}\n      y2={y}\n      x2={width}\n      style={`stroke: var(--grid-line-subdivision-color)`}\n    />\n  {/each}\n\n  {#if xLines}\n    <line\n      x1={0}\n      y1={0}\n      x2={0}\n      y2={height}\n      style={`stroke: var(--visual-math-line-color)`}\n    />\n    <line\n      x1={width}\n      y1={0}\n      x2={width}\n      y2={height}\n      style={`stroke: var(--visual-math-line-color)`}\n    />\n  {/if}\n  {#if yLines}\n    <line\n      x1={0}\n      y1={0}\n      x2={width}\n      y2={0}\n      style={`stroke: var(--visual-math-line-color)`}\n    />\n    <line\n      x1={0}\n      y1={height}\n      x2={width}\n      y2={height}\n      style={`stroke: var(--visual-math-line-color)`}\n    />\n  {/if}\n</pattern>\n","<script lang=\"ts\" context=\"module\">\n  let incrementer = 0;\n\n  const defaultAxisOptions: Partial<IAxisOptions> = {\n    axis: true,\n    lines: 1,\n    labels: (x) => x,\n  };\n</script>\n\n<script lang=\"ts\">\n  import type { IAxisOptions } from \"./math\";\n  import XLabels from \"./XLabels.svelte\";\n  import YLabels from \"./YLabels.svelte\";\n  import GridPattern from \"./GridPattern.svelte\";\n\n  export let subdivisions: number | false = false;\n  export let xAxis: Partial<IAxisOptions> = {\n    subdivisions,\n    ...defaultAxisOptions,\n  };\n  export let yAxis: Partial<IAxisOptions> = {\n    subdivisions,\n    ...defaultAxisOptions,\n  };\n\n  $: xAxisOptions = {\n    subdivisions,\n    ...defaultAxisOptions,\n    ...xAxis,\n  } as IAxisOptions;\n  $: yAxisOptions = {\n    subdivisions,\n    ...defaultAxisOptions,\n    ...yAxis,\n  } as IAxisOptions;\n\n  const id = `visual-math-grid-${incrementer++}`;\n</script>\n\n<defs>\n  <GridPattern\n    {id}\n    xLines={xAxisOptions.lines}\n    yLines={yAxisOptions.lines}\n    xSubdivisions={xAxisOptions.subdivisions}\n    ySubdivisions={yAxisOptions.subdivisions}\n  />\n</defs>\n\n<rect\n  fill={`url(#${id})`}\n  x={-10000000}\n  y={-10000000}\n  width={20000000}\n  height={20000000}\n/>\n\n{#if xAxis.labels}\n  <XLabels\n    labelMaker={xAxisOptions.labels}\n    separation={xAxisOptions.lines || 1}\n  />\n{/if}\n{#if yAxis.labels}\n  <YLabels\n    labelMaker={yAxisOptions.labels}\n    separation={yAxisOptions.lines || 1}\n  />\n{/if}\n\n{#if xAxisOptions.axis}\n  <line\n    x1={-10000000}\n    x2={10000000}\n    y1={0}\n    y2={0}\n    class=\"transform-y-to-center\"\n  />\n{/if}\n\n{#if yAxisOptions.axis}\n  <line\n    x1={0}\n    x2={0}\n    y1={-10000000}\n    y2={10000000}\n    class=\"transform-x-to-center\"\n  />\n{/if}\n\n<style>\n  line {\n    stroke: var(--visual-math-origin-color);\n  }\n</style>\n","<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import { getScaleContext } from \"./math\";\n\n  export let center: vec2 = vec2.fromValues(0, 0);\n  export let radius: vec2 = vec2.fromValues(1, 1);\n  export let angle: number = 0;\n  export let strokeStyle: string = \"solid\";\n  export let strokeOpacity: number = 1.0;\n  export let weight: number = 2;\n  export let color: string = \"var(--visual-math-fg)\";\n  export let fillOpacity: number = 0.15;\n\n  let scaleContext = getScaleContext();\n  $: cssScale = $scaleContext.cssScale;\n  $: rotate = `rotate(${(angle * 180) / Math.PI} ${center[0]} ${center[1]})`;\n</script>\n\n<ellipse\n  cx={center[0]}\n  cy={center[1]}\n  rx={Math.abs(radius[0])}\n  ry={Math.abs(radius[1])}\n  stroke-width={weight}\n  stroke-dasharray={strokeStyle === \"dashed\" ? \"4,3\" : undefined}\n  transform={`${cssScale} ${rotate}`}\n  {...$$restProps}\n  style={`\n    stroke: ${color};\n    fill: ${color};\n    fill-opacity: ${fillOpacity};\n    stroke-opacity: ${strokeOpacity};\n    ${$$restProps.style || \"\"}\n  `}\n/>\n\n<style>\n  ellipse {\n    vector-effect: non-scaling-stroke;\n  }\n</style>\n","<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import Ellipse from \"./Ellipse.svelte\";\n\n  export let center: vec2 = vec2.fromValues(0, 0);\n  export let radius: number = 1;\n  export let angle: number = 0;\n  export let strokeStyle: string = \"solid\";\n  export let strokeOpacity: number = 1.0;\n  export let weight: number = 2;\n  export let color: string = \"var(--visual-math-fg)\";\n  export let fillOpacity: number = 0.15;\n\n  let ellipseRadius = vec2.fromValues(radius, radius);\n  $: ellipseRadius = vec2.set(ellipseRadius, radius, radius);\n</script>\n\n<Ellipse\n  {center}\n  radius={ellipseRadius}\n  {angle}\n  {strokeStyle}\n  {strokeOpacity}\n  {weight}\n  {color}\n  {fillOpacity}\n  {...$$restProps}\n/>\n","function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {\n        values: [0, 0],\n        initial: [0, 0]\n      };\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      config,\n      ingKey,\n      args\n    } = this;\n    const {\n      transform,\n      threshold = [0, 0]\n    } = config;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._delta = [0, 0];\n    state._threshold = V.sub(transform(threshold), transform([0, 0])).map(Math.abs);\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.initial = state.values;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    const [_m0, _m1] = config.transform(state._movement);\n    const [_t0, _t1] = state._threshold;\n    let [_s0, _s1] = state._step;\n    if (_s0 === false) _s0 = Math.abs(_m0) >= _t0 && Math.sign(_m0) * _t0;\n    if (_s1 === false) _s1 = Math.abs(_m1) >= _t1 && Math.sign(_m1) * _t1;\n    state.intentional = _s0 !== false || _s1 !== false;\n    if (!state.intentional) return;\n    state._step = [_s0, _s1];\n    const movement = [0, 0];\n    movement[0] = _s0 !== false ? _m0 - _s0 : 0;\n    movement[1] = _s1 !== false ? _m1 - _s1 : 0;\n    if (this.intent) this.intent(movement);\n\n    if (state._active && !state._blocked || state.active) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        const previousMovement = state.movement;\n        state.movement = movement;\n        this.computeOffset();\n\n        if (!state.last) {\n          state.delta = V.sub(movement, previousMovement);\n          const absoluteDelta = state.delta.map(Math.abs);\n          V.addTo(state.distance, absoluteDelta);\n          state.direction = state.delta.map(Math.sign);\n\n          if (!state.first && dt > 0) {\n            state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n          }\n        }\n      }\n    }\n\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    this.computeMovement();\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy]) {\n  const d = Math.abs(dx) - Math.abs(dy);\n  if (d > 0) return 'x';\n  if (d < 0) return 'y';\n  return undefined;\n}\n\nfunction restrictVectorToAxis(v, axis) {\n  switch (axis) {\n    case 'x':\n      v[1] = 0;\n      break;\n\n    case 'y':\n      v[0] = 0;\n      break;\n  }\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  intent(v) {\n    this.state.axis = this.state.axis || selectAxis(v);\n    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;\n    if (this.state._blocked) return;\n\n    if (this.config.axis || this.config.lockDirection) {\n      restrictVectorToAxis(v, this.state.axis);\n    }\n  }\n\n}\n\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    return value || config.shared.transform;\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n    }\n\n  });\n}\n\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n\n    if (this.config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    state.values = pointerValues(event);\n    state.initial = state.values;\n\n    if (config.preventScroll) {\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId && id !== state._pointerId) return;\n    const values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(values, state.values);\n      state.values = values;\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed) {\n      this.timeoutStore.remove('dragDelay');\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScroll && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= 3 && dy <= 3;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    let device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer') {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this), {\n      passive: false\n    });\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScroll, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', this.startPointerDrag.bind(this), this.config.delay, event);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    const state = this.state;\n\n    if (deltaFn) {\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: supportsTouchEvents(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  pointerLock(_v, _k, {\n    pointer: {\n      lock = false,\n      touch = false\n    } = {}\n  }) {\n    this.useTouch = SUPPORT.touch && touch;\n    return SUPPORT.pointerLock && lock;\n  },\n\n  device(_v, _k) {\n    if (this.useTouch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScroll(value = false, _k, {\n    preventScrollAxis = 'y'\n  }) {\n    if (preventScrollAxis) this.preventScrollAxis = preventScrollAxis;\n    if (!SUPPORT.touchscreen) return false;\n    if (typeof value === 'number') return value;\n    return value ? DEFAULT_PREVENT_SCROLL_DELAY : false;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true\n    } = {}\n  }) {\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? 3 : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 60;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      movement,\n      lastOffset\n    } = this.state;\n    this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0] - 1, offset[1] - lastOffset[1]];\n  }\n\n  intent(v) {\n    const state = this.state;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(v[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v[1]);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n\n    if (this.config.lockDirection) {\n      if (state.axis === 'scale') v[1] = 0;else if (state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    state.values = [payload.distance, payload.angle];\n    state.initial = state.values;\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state.values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    state.values = [payload.distance, payload.angle - 360 * delta_turns];\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state.values[0] / state.initial[0] - 1, state.values[1] - state.initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    state.values = [event.scale, event.rotation];\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    state.values = [event.scale, event.rotation];\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    if (!event.ctrlKey) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO, 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  useTouch(_v, _k, {\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    return SUPPORT.touch && touch;\n  },\n\n  device(_v, _k, config) {\n    const sharedConfig = config.shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (this.useTouch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    const state = this.state;\n    state.values = pointerValues(event);\n    this.compute(event);\n    state.initial = state.values;\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state.values);\n    V.addTo(state._movement, state._delta);\n    state.values = values;\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state.values);\n    V.addTo(state._movement, state._delta);\n    state.values = values;\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(this.state._movement, state._delta);\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.state.values = pointerValues(event);\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state.values);\n    state.values = values;\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, hoverAction as h, isTouch as i, moveAction as m, pinchAction as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, d as toHandlerProp } from './actions-0efe52f5.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst identity = v => v;\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value = identity) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) switch (typeof resolver) {\n    case 'function':\n      result[key] = resolver.call(result, config[key], key, config);\n      break;\n\n    case 'object':\n      result[key] = resolveWith(config[key], resolver);\n      break;\n\n    case 'boolean':\n      if (resolver) result[key] = config[key];\n      break;\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup') this.pointerIds.delete(event.pointerId);else this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      let eventKey = handlerProp.substr(2).toLowerCase();\n      const capture = !!~eventKey.indexOf('capture');\n      const passive = !!~eventKey.indexOf('passive');\n      if (capture || passive) eventKey = eventKey.replace(/capture|passive/g, '');\n\n      this._targetEventStore.add(target, eventKey, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst Recognizer = function Recognizer(target, handlers, config, gestureKey, nativeHandlers) {\n  this._gestureKey = gestureKey;\n  this._ctrl = new Controller(handlers);\n\n  this._ctrl.applyHandlers(handlers, nativeHandlers);\n\n  this._ctrl.applyConfig(_objectSpread2(_objectSpread2({}, config), {}, {\n    target\n  }), this._gestureKey);\n\n  this._ctrl.effect();\n};\n\nRecognizer.prototype.destroy = function () {\n  this._ctrl.clean();\n};\n\nconst DragGesture = function DragGesture(target, handler, config = {}) {\n  registerAction(dragAction);\n  return new Recognizer(target, {\n    drag: handler\n  }, config, 'drag');\n};\n\nconst PinchGesture = function PinchGesture(target, handler, config = {}) {\n  registerAction(pinchAction);\n  return new Recognizer(target, {\n    pinch: handler\n  }, config, 'pinch');\n};\n\nconst WheelGesture = function WheelGesture(target, handler, config = {}) {\n  registerAction(wheelAction);\n  return new Recognizer(target, {\n    wheel: handler\n  }, config, 'wheel');\n};\n\nconst ScrollGesture = function ScrollGesture(target, handler, config = {}) {\n  registerAction(scrollAction);\n  return new Recognizer(target, {\n    scroll: handler\n  }, config, 'scroll');\n};\n\nconst MoveGesture = function MoveGesture(target, handler, config = {}) {\n  registerAction(moveAction);\n  return new Recognizer(target, {\n    move: handler\n  }, config, 'move');\n};\n\nconst HoverGesture = function HoverGesture(target, handler, config = {}) {\n  registerAction(hoverAction);\n  return new Recognizer(target, {\n    hover: handler\n  }, config, 'hover');\n};\n\nfunction createGesture(actions) {\n  actions.forEach(registerAction);\n  return function (target, _handlers, _config = {}) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config);\n    return new Recognizer(target, handlers, config, undefined, nativeHandlers);\n  };\n}\n\nconst Gesture = function Gesture(target, handlers, config = {}) {\n  const gestureFunction = createGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return gestureFunction(target, handlers, config);\n};\n\nexport { DragGesture, Gesture, HoverGesture, MoveGesture, PinchGesture, ScrollGesture, WheelGesture };\n","<script lang=\"ts\" context=\"module\">\n  const VEC2_0 = vec2.create();\n</script>\n\n<script lang=\"ts\">\n  import type { FullGestureState } from \"@use-gesture/vanilla\";\n  import { DragGesture } from \"@use-gesture/vanilla\";\n  import { mat2d, vec2 } from \"gl-matrix\";\n  import { onMount } from \"svelte\";\n  import { getScaleContext } from \"./math\";\n\n  export let point: vec2 = vec2.create();\n  export let color: string = \"var(--visual-math-blue)\";\n  export let transform: mat2d = mat2d.create();\n  export let constrain:\n    | \"horizontal\"\n    | \"vertical\"\n    | ((position: vec2) => vec2)\n    | undefined = undefined;\n\n  let intialPoint = vec2.fromValues(point[0], point[1]);\n  let constraintFunction = (point: vec2) => point;\n  $: if (constrain === \"horizontal\") {\n    constraintFunction = ([x, _y]) => [x, intialPoint[1]];\n  } else if (constrain === \"vertical\") {\n    constraintFunction = ([_x, y]) => [intialPoint[0], y];\n  } else if (typeof constrain === \"function\") {\n    constraintFunction = constrain;\n  }\n\n  point = constraintFunction(point);\n\n  let scaleContext = getScaleContext();\n  $: scaleX = $scaleContext.scaleX;\n  $: scaleY = $scaleContext.scaleY;\n  $: inversePixelMatrix = $scaleContext.inversePixelMatrix;\n  let display = vec2.create();\n  $: display = vec2.transformMat2d(display, point, transform);\n\n  let inverseTransform = mat2d.create();\n  $: inverseTransform = mat2d.invert(inverseTransform, transform);\n\n  let element: SVGGElement;\n  let startPoint = vec2.create();\n  let dragging = false;\n\n  $: onDrag = (\n    state: Omit<FullGestureState<\"drag\">, \"event\"> & {\n      event: PointerEvent | MouseEvent | TouchEvent | KeyboardEvent;\n    }\n  ) => {\n    state.event?.stopPropagation();\n    dragging = state.down;\n    const movement = vec2.transformMat2d(\n      VEC2_0,\n      state.movement,\n      inversePixelMatrix\n    );\n\n    if (state.first) {\n      startPoint = vec2.transformMat2d(startPoint, point, transform);\n    }\n    vec2.add(point, startPoint, movement);\n    vec2.transformMat2d(point, point, inverseTransform);\n    point = constraintFunction(point);\n  };\n\n  onMount(() => {\n    const dragGesture = new DragGesture(element, onDrag);\n\n    return () => {\n      dragGesture.destroy();\n    };\n  });\n</script>\n\n<g bind:this={element}>\n  <circle\n    cx={scaleX(display[0])}\n    cy={scaleY(display[1])}\n    r={30}\n    fill=\"transparent\"\n  />\n  <circle\n    cx={scaleX(display[0])}\n    cy={scaleY(display[1])}\n    r={6}\n    fill={color}\n    stroke={color}\n    stroke-opacity={0.25}\n    class:draggable={dragging}\n    tabIndex={0}\n  />\n</g>\n","<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import { getScaleContext } from \"./math\";\n\n  export let point: vec2 = vec2.create();\n  export let color: string = \"var(--visual-math-fg)\";\n  export let opacity = 1;\n\n  const scaleContext = getScaleContext();\n  $: scaleX = $scaleContext.scaleX;\n  $: scaleY = $scaleContext.scaleY;\n</script>\n\n<circle\n  cx={scaleX(point[0])}\n  cy={scaleY(point[1])}\n  r={6}\n  {...$$restProps}\n  style={`fill: ${color}; opacity: ${opacity}; ${$$restProps.style}`}\n/>\n","<script lang=\"ts\" context=\"module\">\n  const VEC2_0 = vec2.create();\n</script>\n\n<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import { getScaleContext } from \"./math\";\n\n  export let point1: vec2 = vec2.create();\n  export let point2: vec2 = vec2.create();\n  export let color = \"var(--visual-math-fg)\";\n  export let style = \"solid\";\n  export let weight = 2;\n  export let opacity = 1;\n\n  const scaleContext = getScaleContext();\n  $: pixelMatrix = $scaleContext.pixelMatrix;\n  let segment = vec2.create();\n  $: segment = vec2.scale(\n    segment,\n    vec2.normalize(segment, vec2.sub(VEC2_0, point2, point1)),\n    100000\n  );\n\n  let scaledPoint1 = vec2.create();\n  let scaledPoint2 = vec2.create();\n  $: scaledPoint1 = vec2.transformMat2d(\n    scaledPoint1,\n    vec2.sub(VEC2_0, point1, segment),\n    pixelMatrix\n  );\n  $: scaledPoint2 = vec2.transformMat2d(\n    scaledPoint2,\n    vec2.add(VEC2_0, point2, segment),\n    pixelMatrix\n  );\n</script>\n\n<line\n  x1={scaledPoint1[0]}\n  y1={scaledPoint1[1]}\n  x2={scaledPoint2[0]}\n  y2={scaledPoint2[1]}\n  style={`stroke: ${color}`}\n  stroke-width={weight}\n  {opacity}\n  stroke-dasharray={style === \"dashed\" ? \"4,3\" : undefined}\n/>\n","<script lang=\"ts\" context=\"module\">\n  const VEC2_0 = vec2.create();\n  const ZERO = vec2.create();\n  const RIGHT = vec2.fromValues(1, 0);\n</script>\n\n<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import ThroughPoints from \"./ThroughPoints.svelte\";\n\n  export let point: vec2 = vec2.create();\n  export let angle = 0;\n  export let color = \"var(--visual-math-fg)\";\n  export let style = \"solid\";\n  export let weight = 2;\n  export let opacity = 1;\n\n  let point2 = vec2.create();\n  $: point2 = vec2.add(point2, point, vec2.rotate(VEC2_0, RIGHT, ZERO, angle));\n</script>\n\n<ThroughPoints point1={point} {point2} {color} {opacity} {style} {weight} />\n","<script lang=\"ts\">\n  import { vec2 } from \"gl-matrix\";\n  import PointAngle from \"./PointAngle.svelte\";\n\n  export let point: vec2 = vec2.create();\n  export let slope = 0;\n  export let color = \"var(--visual-math-fg)\";\n  export let style = \"solid\";\n  export let weight = 2;\n  export let opacity = 1;\n\n  let angle = Math.atan(slope);\n  $: angle = Math.atan(slope);\n</script>\n\n<PointAngle {point} {angle} {color} {opacity} {style} {weight} />\n","<script lang=\"ts\" context=\"module\">\n  const VEC2_0 = vec2.create();\n\n  function getMouseWheelDirection(e: any) {\n    if (typeof e.detail == \"number\" && e.detail !== 0) {\n      if (e.detail > 0) {\n        return -1;\n      } else if (e.detail < 0) {\n        return 1;\n      }\n    } else if (typeof e.wheelDelta === \"number\") {\n      if (e.wheelDelta < 0) {\n        return -1;\n      } else if (e.wheelDelta > 0) {\n        return 1;\n      }\n    }\n    return undefined;\n  }\n</script>\n\n<script lang=\"ts\">\n  import type { FullGestureState } from \"@use-gesture/vanilla\";\n  import { DragGesture, WheelGesture } from \"@use-gesture/vanilla\";\n  import { range } from \"@aicacia/core\";\n  import { vec2, mat2d } from \"gl-matrix\";\n  import {\n    setCoordinateContext,\n    setMapContext,\n    setPanesContext,\n    setScaleContext,\n  } from \"./math\";\n  import { writable } from \"svelte/store\";\n  import { onMount } from \"svelte\";\n\n  export let width: string | number = 500;\n  export let height: string | number = 500;\n  export let pan = true;\n  export let zoom = true;\n  export let xAxisExtent: vec2 = vec2.fromValues(-5.5, 5.5);\n  export let yAxisExtent: vec2 = vec2.fromValues(-5.5, 5.5);\n\n  let actualWidth: number = typeof width === \"number\" ? width : 500;\n  let actualHeight: number = typeof height === \"number\" ? height : 500;\n  $: desiredCssWidth = width === \"auto\" ? \"100%\" : `${width}px`;\n  $: desiredCssHeight = height === \"auto\" ? \"100%\" : `${height}px`;\n\n  $: {\n    const aspect = actualWidth / actualHeight,\n      halfZoomAmount = zoomAmount * 0.5,\n      newZoomAmount = zoomAmount * aspect,\n      halfNewZoomAmount = newZoomAmount * 0.5;\n\n    xAxisExtent[0] = -halfNewZoomAmount;\n    xAxisExtent[1] = halfNewZoomAmount;\n    yAxisExtent[0] = -halfZoomAmount;\n    yAxisExtent[1] = halfZoomAmount;\n  }\n\n  let zoomAmount = Math.min(\n    xAxisExtent[1] - xAxisExtent[0],\n    yAxisExtent[1] - yAxisExtent[0]\n  );\n\n  let offset = vec2.fromValues(0, 0);\n  let min = vec2.fromValues(xAxisExtent[0], yAxisExtent[0]);\n  let max = vec2.fromValues(xAxisExtent[1], yAxisExtent[1]);\n\n  $: min = vec2.add(\n    min,\n    offset,\n    vec2.set(VEC2_0, xAxisExtent[0], yAxisExtent[0])\n  );\n  $: max = vec2.add(\n    max,\n    offset,\n    vec2.set(VEC2_0, xAxisExtent[1], yAxisExtent[1])\n  );\n\n  $: mapX = (x: number) => ((x - min[0]) / (max[0] - min[0])) * actualWidth;\n  $: mapY = (y: number) => ((y - min[1]) / (max[1] - min[1])) * actualHeight;\n\n  let span = vec2.create();\n  $: span = vec2.sub(span, max, min);\n\n  $: scaleX = (x: number) => (x / span[0]) * actualWidth;\n  $: scaleY = (y: number) => (-y / span[1]) * actualHeight;\n  $: unscaleX = (x: number) => (x / actualWidth) * xSpan;\n  $: unscaleY = (y: number) => (-y / actualHeight) * ySpan;\n\n  let pixelMatrix = mat2d.create();\n  $: pixelMatrix = mat2d.fromScaling(\n    pixelMatrix,\n    vec2.set(VEC2_0, scaleX(1), scaleY(1))\n  );\n\n  let inversePixelMatrix = mat2d.create();\n  $: inversePixelMatrix = mat2d.fromScaling(\n    inversePixelMatrix,\n    vec2.set(VEC2_0, unscaleX(1), unscaleY(1))\n  );\n\n  $: cssScale = `scale(${scaleX(1)} ${scaleY(1)})`;\n\n  let base = 2;\n  let xPanes: vec2[] = [];\n  let yPanes: vec2[] = [];\n  let xPaneRange = vec2.create();\n  let yPaneRange = vec2.create();\n\n  $: xSpan = max[0] - min[0];\n  $: xStep = Math.pow(base, Math.round(Math.log10(xSpan) / Math.log10(base)));\n  $: xLowerBound = Math.floor(min[0] / xStep) * xStep;\n  $: xUpperBound = Math.ceil(max[0] / xStep) * xStep;\n  $: xPanes = range(xLowerBound, xUpperBound, xStep)\n    .iter()\n    .map((xMin) => vec2.fromValues(xMin, xMin + xStep))\n    .toArray();\n  $: xPaneRange = vec2.set(xPaneRange, xLowerBound, xUpperBound);\n\n  $: ySpan = max[1] - min[1];\n  $: yStep = Math.pow(base, Math.round(Math.log10(ySpan) / Math.log10(base)));\n  $: yLowerBound = Math.floor(min[0] / yStep) * yStep;\n  $: yUpperBound = Math.ceil(max[0] / yStep) * yStep;\n  $: yPanes = range(yLowerBound, yUpperBound, yStep)\n    .iter()\n    .map((yMin) => vec2.fromValues(yMin, yMin + yStep))\n    .toArray();\n  $: yPaneRange = vec2.set(yPaneRange, yLowerBound, yUpperBound);\n\n  let panesContext = writable({\n    xPanes,\n    yPanes,\n    xPaneRange,\n    yPaneRange,\n  });\n  setPanesContext(panesContext);\n\n  $: panesContext.set({\n    xPanes,\n    yPanes,\n    xPaneRange,\n    yPaneRange,\n  });\n\n  let coordinateContext = writable({\n    min,\n    max,\n    width: actualWidth,\n    height: actualHeight,\n  });\n  setCoordinateContext(coordinateContext);\n  $: coordinateContext.set({\n    min,\n    max,\n    width: actualWidth,\n    height: actualHeight,\n  });\n\n  let scaleContext = writable({\n    zoomAmount,\n    scaleX,\n    scaleY,\n    span,\n    pixelMatrix,\n    inversePixelMatrix,\n    cssScale,\n  });\n  setScaleContext(scaleContext);\n  $: scaleContext.set({\n    zoomAmount,\n    scaleX,\n    scaleY,\n    span,\n    pixelMatrix,\n    inversePixelMatrix,\n    cssScale,\n  });\n\n  let mapContext = writable({\n    mapX,\n    mapY,\n  });\n  setMapContext(mapContext);\n  $: mapContext.set({\n    mapX,\n    mapY,\n  });\n\n  let element: HTMLDivElement;\n\n  $: onDrag = (\n    state: Omit<FullGestureState<\"drag\">, \"event\"> & {\n      event: PointerEvent | MouseEvent | TouchEvent | KeyboardEvent;\n    }\n  ) => {\n    if (!pan) {\n      return;\n    }\n    offset[0] =\n      (-state.offset[0] / actualWidth) * (xAxisExtent[1] - xAxisExtent[0]);\n    offset[1] =\n      (-state.offset[1] / actualHeight) * (yAxisExtent[1] - yAxisExtent[0]);\n  };\n\n  $: onMouseWheel = (\n    state: Omit<FullGestureState<\"wheel\">, \"event\"> & {\n      event: PointerEvent | MouseEvent | TouchEvent | KeyboardEvent;\n    }\n  ) => {\n    if (!zoom || state.last) {\n      return;\n    }\n    const wheelDirection = getMouseWheelDirection(state.event as WheelEvent);\n\n    if (wheelDirection && (zoomAmount > 3 || wheelDirection < 0)) {\n      xAxisExtent = vec2.set(\n        xAxisExtent,\n        xAxisExtent[0] + wheelDirection,\n        xAxisExtent[1] - wheelDirection\n      );\n      yAxisExtent = vec2.set(\n        yAxisExtent,\n        yAxisExtent[0] + wheelDirection,\n        yAxisExtent[1] - wheelDirection\n      );\n      zoomAmount = Math.min(\n        xAxisExtent[1] - xAxisExtent[0],\n        yAxisExtent[1] - yAxisExtent[0]\n      );\n    }\n  };\n\n  onMount(() => {\n    const dragGesture = new DragGesture(element, onDrag),\n      wheelGesture = new WheelGesture(element, onMouseWheel);\n\n    return () => {\n      dragGesture.destroy();\n      wheelGesture.destroy();\n    };\n  });\n</script>\n\n<div\n  bind:this={element}\n  bind:offsetWidth={actualWidth}\n  bind:offsetHeight={actualHeight}\n  class=\"visual-math\"\n  style={`width: ${desiredCssWidth}; height: ${desiredCssHeight}`}\n>\n  <svg\n    width={actualWidth}\n    height={actualHeight}\n    viewBox={`${-mapX(0)} ${-mapY(0)} ${actualWidth} ${actualHeight}`}\n    preserveAspectRatio=\"xMidYMin\"\n    style={`width: ${width}; touch-action: ${pan ? \"none\" : \"auto\"};`}\n  >\n    <slot />\n  </svg>\n</div>\n\n<style>\n  .visual-math {\n    display: block;\n    background: var(--visual-math-bg);\n    overflow: hidden;\n    user-select: none;\n    font-family: sans-serif;\n    font-variant-numeric: tabular-nums;\n\n    --visual-math-bg: #f1f1f1;\n    --visual-math-fg: black;\n\n    --visual-math-origin-color: var(--visual-math-fg);\n    --visual-math-line-color: #555;\n    --grid-line-subdivision-color: #222;\n\n    --visual-math-red: #f10000;\n    --visual-math-orange: #f18100;\n    --visual-math-yellow: #f1f100;\n    --visual-math-green: #00f181;\n    --visual-math-blue: #0000f1;\n    --visual-math-indigo: #8100f1;\n    --visual-math-violet: #8100f1;\n    --visual-math-pink: #f18181;\n  }\n\n  .visual-math text {\n    fill: var(--visual-math-fg);\n    cursor: default;\n  }\n\n  .visual-math path {\n    stroke: var(--visual-math-fg);\n  }\n\n  .visual-math .draggable {\n    transition: r 0.2s ease, stroke-width 0.2s ease;\n    stroke-width: 1rem;\n    cursor: grab;\n    outline: 0 !important;\n\n    color: hsl(0, 100%, 47%);\n  }\n\n  .visual-math .draggable:active {\n    cursor: grabbing;\n  }\n\n  .visual-math .draggable:focus,\n  .visual-math circle.draggable:hover,\n  .visual-math circle.draggable.dragging {\n    r: 0.9rem;\n    stroke-width: 0;\n  }\n</style>\n"],"names":["SCALE_CONTEXT_KEY","getScaleContext","getContext","COORDINATE_CONTEXT_KEY","getCoordinateContext","MAP_CONTEXT_KEY","getMapContext","PANES_CONTEXT_KEY","getPanesContext","snappedRange","min","max","step","range","Math","floor","ceil","iter","toArray","ctx","insert","length","separation","labelMaker","scaleContext","panesContext","scaleX","$scaleContext","xPanes","$panesContext","xs","filter","x","abs","scaleY","yPanes","ys","y","id","xLines","yLines","xSubdivisions","ySubdivisions","context","$context","width","height","pixelXDistance","pixelYDistance","labels","lines","subdivisions","axis","incrementer","defaultAxisOptions","xAxis","Object","assign","yAxis","xAxisOptions","yAxisOptions","undefined","style","center","vec2","fromValues","radius","angle","strokeStyle","strokeOpacity","weight","color","fillOpacity","cssScale","rotate","PI","ellipseRadius","set","V","toVector","v","fallback","Array","isArray","add","v1","v2","sub","addTo","subTo","rubberband","distance","dimension","constant","Infinity","pow","rubberbandIfOutOfBounds","position","clamp","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","EVENT_TYPE_MAP","pointer","start","change","end","mouse","touch","gesture","capitalize","string","toUpperCase","slice","isTouch","event","getValueEvent","type","changedTouches","targetTouches","getTouchList","touchIds","from","touches","e","_event$currentTarget","_event$currentTarget$","currentTarget","contains","call","getCurrentTargetTouchList","map","identifier","pointerId","valueEvent","pointerValues","clientX","clientY","args","noop","chain","fns","result","fn","this","assignDefault","CoordinatesEngine","constructor","ctrl","state","values","initial","init","reset","shared","eventStore","gestureEventStores","timeoutStore","gestureTimeoutStores","config","sharedConfig","handler","handlers","ingKey","transform","threshold","_active","active","_blocked","_force","_step","intentional","_movement","_distance","_delta","_threshold","_bounds","memo","elapsedTime","direction","velocity","movement","delta","timeStamp","lastOffset","offset","startTime","compute","dt","pointerIds","size","locked","document","pointerLockElement","payload","buttons","shiftKey","altKey","metaKey","ctrlKey","getEventDetails","down","pressed","_absoluteDelta","_m0","_m1","_t0","_t1","_s0","_s1","sign","intent","first","last","bounds","setup","previousMovement","computeOffset","absoluteDelta","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","computeRubberband","computeMovement","emit","clean","triggerAllEvents","aliasKey","super","dx","dy","d","selectAxis","lockDirection","restrictVectorToAxis","commonConfigResolver","enabled","_k","coordinatesConfigResolver","_v","current","HTMLElement","left","right","top","bottom","KEYS_DELTA_MAP","ArrowRight","factor","ArrowLeft","ArrowUp","ArrowDown","isBrowser","window","createElement","supportsTouchEvents","SUPPORT","GestureEvent","supportsGestureEvents","touchscreen","navigator","maxTouchPoints","pointerLock","dragConfigResolver","lock","useTouch","device","preventScroll","preventScrollAxis","pointerCapture","capture","filterTaps","swipe","duration","delay","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","mouseOnly","wheelConfigResolver","EngineMap","Map","ConfigResolverMap","registerAction","action","engine","resolver","dragAction","_pointerId","_pointerActive","_keyboardActive","_preventScroll","_delayed","tap","canceled","cancel","bind","boundRect","getBoundingClientRect","targetRect","setTimeout","setActive","pointerClean","pointerDown","setEventIds","setPointerCapture","setupPointer","setupScrollPrevention","setupDelayTrigger","startPointerDrag","pointerMove","movementX","movementY","remove","pointerUp","hasPointerCapture","releasePointerCapture","_unused","dirx","diry","vx","vy","mx","my","svx","svy","sx","sy","sdt","pointerClick","preventDefault","stopPropagation","requestPointerLock","exitPointerLock","cancelable","persist","persistEvent","passive","keyDown","deltaFn","keyUp","bindFunction","wheelAction","wheel","wheelChange","wheelEnd","deltaX","deltaY","deltaMode","wheelValues","_objectWithoutProperties","excluded","sourceKeys","indexOf","_objectWithoutPropertiesLoose","sourceSymbolKeys","prototype","propertyIsEnumerable","identity","sharedConfigResolver","eventOptions","_excluded","resolveWith","resolvers","entries","EventStore","_ctrl","element","options","deviceProps","toDomEventType","addEventListener","_listeners","removeEventListener","TimeoutStore","callback","ms","_timeouts","timeout","get","clearTimeout","clear","Controller","Set","internalHandlers","drag","setupGesture","scroll","move","pinch","hover","resolveGestures","delete","applyHandlers","nativeHandlers","applyConfig","gestureKey","_ref","rest","_config","parse","_targetEventStore","gestures","effect","props","bindToProps","eventKey","handlerProp","substr","toLowerCase","replace","withPassiveOption","isNative","_options$capture","_options$passive","actionKey","toHandlerProp","Recognizer","_gestureKey","destroy","DragGesture","WheelGesture","append","VEC2_0","create","point","mat2d","constrain","intialPoint","constraintFunction","display","inverseTransform","startPoint","dragging","onMount","dragGesture","onDrag","_y","_x","inversePixelMatrix","invert","_a","transformMat2d","opacity","point1","point2","segment","scaledPoint1","scaledPoint2","pixelMatrix","scale","normalize","ZERO","RIGHT","slope","atan","pan","zoom","xAxisExtent","yAxisExtent","actualWidth","actualHeight","zoomAmount","span","xPaneRange","yPaneRange","setContext","coordinateContext","setCoordinateContext","setScaleContext","mapContext","mapX","mapY","setMapContext","wheelGesture","onMouseWheel","desiredCssWidth","desiredCssHeight","wheelDirection","detail","wheelDelta","getMouseWheelDirection","halfZoomAmount","halfNewZoomAmount","xSpan","unscaleX","ySpan","unscaleY","fromScaling","xStep","round","log10","xLowerBound","xUpperBound","xMin","yStep","yLowerBound","yUpperBound","yMin"],"mappings":"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"}