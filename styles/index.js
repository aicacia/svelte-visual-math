import { SvelteComponent, init, safe_not_equal, svg_element, text, attr, insert, append, set_data, detach, noop, destroy_each, component_subscribe, empty, create_component, mount_component, transition_in, transition_out, destroy_component, space, group_outros, check_outros, assign, set_svg_attributes, toggle_class, get_spread_update, compute_rest_props, exclude_internal_props, get_spread_object, binding_callbacks, create_slot, element, add_render_callback, add_resize_listener, update_slot_base, get_all_dirty_from_scope, get_slot_changes } from 'svelte/internal';
import { range } from '@aicacia/core';
import { getContext, setContext, onMount } from 'svelte';
import { vec2, mat2d } from 'gl-matrix';
import { DragGesture, WheelGesture } from '@use-gesture/vanilla';
import { writable } from 'svelte/store';

const SCALE_CONTEXT_KEY = {};
function getScaleContext() {
    return getContext(SCALE_CONTEXT_KEY);
}
function setScaleContext(context) {
    setContext(SCALE_CONTEXT_KEY, context);
}
const COORDINATE_CONTEXT_KEY = {};
function getCoordinateContext() {
    return getContext(COORDINATE_CONTEXT_KEY);
}
function setCoordinateContext(context) {
    setContext(COORDINATE_CONTEXT_KEY, context);
}
const MAP_CONTEXT_KEY = {};
function getMapContext() {
    return getContext(MAP_CONTEXT_KEY);
}
function setMapContext(context) {
    setContext(MAP_CONTEXT_KEY, context);
}
const PANES_CONTEXT_KEY = {};
function getPanesContext() {
    return getContext(PANES_CONTEXT_KEY);
}
function setPanesContext(context) {
    setContext(PANES_CONTEXT_KEY, context);
}
function snappedRange(min, max, step) {
    return range(Math.floor(min / step) * step, Math.ceil(max / step) * step, step)
        .iter()
        .toArray();
}

/* src/XLabels.svelte generated by Svelte v3.42.4 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (12:2) {#each xs as x}
function create_each_block$2(ctx) {
	let text_1;

	let t_value = (/*labelMaker*/ ctx[0]
	? /*labelMaker*/ ctx[0](/*x*/ ctx[9])
	: /*x*/ ctx[9]) + "";

	let t;
	let text_1_x_value;
	let text_1_y_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(t_value);
			attr(text_1, "x", text_1_x_value = /*scaleX*/ ctx[1](/*x*/ ctx[9]));
			attr(text_1, "y", text_1_y_value = 5);
			attr(text_1, "alignment-baseline", "hanging");
			attr(text_1, "text-anchor", "middle");
		},
		m(target, anchor) {
			insert(target, text_1, anchor);
			append(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*labelMaker, xs*/ 5 && t_value !== (t_value = (/*labelMaker*/ ctx[0]
			? /*labelMaker*/ ctx[0](/*x*/ ctx[9])
			: /*x*/ ctx[9]) + "")) set_data(t, t_value);

			if (dirty & /*scaleX, xs*/ 6 && text_1_x_value !== (text_1_x_value = /*scaleX*/ ctx[1](/*x*/ ctx[9]))) {
				attr(text_1, "x", text_1_x_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

function create_fragment$b(ctx) {
	let g;
	let each_value = /*xs*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			g = svg_element("g");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(g, "class", "svelte-133qdtd");
		},
		m(target, anchor) {
			insert(target, g, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaleX, xs, labelMaker*/ 7) {
				each_value = /*xs*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(g);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let scaleX;
	let xPanes;
	let xs;
	let $panesContext;
	let $scaleContext;
	let { separation } = $$props;
	let { labelMaker } = $$props;
	let scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(8, $scaleContext = value));
	let panesContext = getPanesContext();
	component_subscribe($$self, panesContext, value => $$invalidate(7, $panesContext = value));

	$$self.$$set = $$props => {
		if ('separation' in $$props) $$invalidate(5, separation = $$props.separation);
		if ('labelMaker' in $$props) $$invalidate(0, labelMaker = $$props.labelMaker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 256) {
			$$invalidate(1, scaleX = $scaleContext.scaleX);
		}

		if ($$self.$$.dirty & /*$panesContext*/ 128) {
			$$invalidate(6, xPanes = $panesContext.xPanes);
		}

		if ($$self.$$.dirty & /*xPanes, separation, scaleX*/ 98) {
			$$invalidate(2, xs = snappedRange(xPanes[0][0] - separation, xPanes[xPanes.length - 1][1] + separation, separation).filter(x => Math.abs(scaleX(x) - scaleX(0)) > 1));
		}
	};

	return [
		labelMaker,
		scaleX,
		xs,
		scaleContext,
		panesContext,
		separation,
		xPanes,
		$panesContext,
		$scaleContext
	];
}

class XLabels extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { separation: 5, labelMaker: 0 });
	}
}

/* src/YLabels.svelte generated by Svelte v3.42.4 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (12:2) {#each ys as y}
function create_each_block$1(ctx) {
	let text_1;

	let t_value = (/*labelMaker*/ ctx[0]
	? /*labelMaker*/ ctx[0](/*y*/ ctx[9])
	: /*y*/ ctx[9]) + "";

	let t;
	let text_1_x_value;
	let text_1_y_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(t_value);
			attr(text_1, "x", text_1_x_value = 5);
			attr(text_1, "y", text_1_y_value = /*scaleY*/ ctx[1](/*y*/ ctx[9]));
			attr(text_1, "alignment-baseline", "central");
		},
		m(target, anchor) {
			insert(target, text_1, anchor);
			append(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*labelMaker, ys*/ 5 && t_value !== (t_value = (/*labelMaker*/ ctx[0]
			? /*labelMaker*/ ctx[0](/*y*/ ctx[9])
			: /*y*/ ctx[9]) + "")) set_data(t, t_value);

			if (dirty & /*scaleY, ys*/ 6 && text_1_y_value !== (text_1_y_value = /*scaleY*/ ctx[1](/*y*/ ctx[9]))) {
				attr(text_1, "y", text_1_y_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

function create_fragment$a(ctx) {
	let g;
	let each_value = /*ys*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			g = svg_element("g");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(g, "class", "svelte-133qdtd");
		},
		m(target, anchor) {
			insert(target, g, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaleY, ys, labelMaker*/ 7) {
				each_value = /*ys*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(g);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let scaleY;
	let yPanes;
	let ys;
	let $panesContext;
	let $scaleContext;
	let { separation } = $$props;
	let { labelMaker } = $$props;
	let scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(8, $scaleContext = value));
	let panesContext = getPanesContext();
	component_subscribe($$self, panesContext, value => $$invalidate(7, $panesContext = value));

	$$self.$$set = $$props => {
		if ('separation' in $$props) $$invalidate(5, separation = $$props.separation);
		if ('labelMaker' in $$props) $$invalidate(0, labelMaker = $$props.labelMaker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 256) {
			$$invalidate(1, scaleY = $scaleContext.scaleY);
		}

		if ($$self.$$.dirty & /*$panesContext*/ 128) {
			$$invalidate(6, yPanes = $panesContext.yPanes);
		}

		if ($$self.$$.dirty & /*yPanes, separation, scaleY*/ 98) {
			$$invalidate(2, ys = snappedRange(yPanes[0][0] - separation, yPanes[yPanes.length - 1][1] + separation, separation).filter(y => Math.abs(scaleY(y) - scaleY(0)) > 1));
		}
	};

	return [
		labelMaker,
		scaleY,
		ys,
		scaleContext,
		panesContext,
		separation,
		yPanes,
		$panesContext,
		$scaleContext
	];
}

class YLabels extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { separation: 5, labelMaker: 0 });
	}
}

/* src/GridPattern.svelte generated by Svelte v3.42.4 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (30:2) {#each xs as x}
function create_each_block_1(ctx) {
	let line;
	let line_x__value;
	let line_y__value;
	let line_x__value_1;
	let line_style_value;

	return {
		c() {
			line = svg_element("line");
			attr(line, "x1", line_x__value = /*x*/ ctx[16]);
			attr(line, "y1", line_y__value = 0);
			attr(line, "x2", line_x__value_1 = /*x*/ ctx[16]);
			attr(line, "y2", /*height*/ ctx[3]);
			attr(line, "style", line_style_value = `stroke: var(--grid-line-subdivision-color)`);
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*xs*/ 32 && line_x__value !== (line_x__value = /*x*/ ctx[16])) {
				attr(line, "x1", line_x__value);
			}

			if (dirty & /*xs*/ 32 && line_x__value_1 !== (line_x__value_1 = /*x*/ ctx[16])) {
				attr(line, "x2", line_x__value_1);
			}

			if (dirty & /*height*/ 8) {
				attr(line, "y2", /*height*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

// (39:2) {#each ys as y}
function create_each_block(ctx) {
	let line;
	let line_y__value;
	let line_x__value;
	let line_y__value_1;
	let line_style_value;

	return {
		c() {
			line = svg_element("line");
			attr(line, "y1", line_y__value = /*y*/ ctx[13]);
			attr(line, "x1", line_x__value = 0);
			attr(line, "y2", line_y__value_1 = /*y*/ ctx[13]);
			attr(line, "x2", /*width*/ ctx[4]);
			attr(line, "style", line_style_value = `stroke: var(--grid-line-subdivision-color)`);
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*ys*/ 64 && line_y__value !== (line_y__value = /*y*/ ctx[13])) {
				attr(line, "y1", line_y__value);
			}

			if (dirty & /*ys*/ 64 && line_y__value_1 !== (line_y__value_1 = /*y*/ ctx[13])) {
				attr(line, "y2", line_y__value_1);
			}

			if (dirty & /*width*/ 16) {
				attr(line, "x2", /*width*/ ctx[4]);
			}
		},
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

// (49:2) {#if xLines}
function create_if_block_1$1(ctx) {
	let line0;
	let line0_x__value;
	let line0_y__value;
	let line0_x__value_1;
	let line0_style_value;
	let line1;
	let line1_y__value;
	let line1_style_value;

	return {
		c() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(line0, "x1", line0_x__value = 0);
			attr(line0, "y1", line0_y__value = 0);
			attr(line0, "x2", line0_x__value_1 = 0);
			attr(line0, "y2", /*height*/ ctx[3]);
			attr(line0, "style", line0_style_value = `stroke: var(--visual-math-line-color)`);
			attr(line1, "x1", /*width*/ ctx[4]);
			attr(line1, "y1", line1_y__value = 0);
			attr(line1, "x2", /*width*/ ctx[4]);
			attr(line1, "y2", /*height*/ ctx[3]);
			attr(line1, "style", line1_style_value = `stroke: var(--visual-math-line-color)`);
		},
		m(target, anchor) {
			insert(target, line0, anchor);
			insert(target, line1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*height*/ 8) {
				attr(line0, "y2", /*height*/ ctx[3]);
			}

			if (dirty & /*width*/ 16) {
				attr(line1, "x1", /*width*/ ctx[4]);
			}

			if (dirty & /*width*/ 16) {
				attr(line1, "x2", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 8) {
				attr(line1, "y2", /*height*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(line0);
			if (detaching) detach(line1);
		}
	};
}

// (65:2) {#if yLines}
function create_if_block$1(ctx) {
	let line0;
	let line0_x__value;
	let line0_y__value;
	let line0_y__value_1;
	let line0_style_value;
	let line1;
	let line1_x__value;
	let line1_style_value;

	return {
		c() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr(line0, "x1", line0_x__value = 0);
			attr(line0, "y1", line0_y__value = 0);
			attr(line0, "x2", /*width*/ ctx[4]);
			attr(line0, "y2", line0_y__value_1 = 0);
			attr(line0, "style", line0_style_value = `stroke: var(--visual-math-line-color)`);
			attr(line1, "x1", line1_x__value = 0);
			attr(line1, "y1", /*height*/ ctx[3]);
			attr(line1, "x2", /*width*/ ctx[4]);
			attr(line1, "y2", /*height*/ ctx[3]);
			attr(line1, "style", line1_style_value = `stroke: var(--visual-math-line-color)`);
		},
		m(target, anchor) {
			insert(target, line0, anchor);
			insert(target, line1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*width*/ 16) {
				attr(line0, "x2", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 8) {
				attr(line1, "y1", /*height*/ ctx[3]);
			}

			if (dirty & /*width*/ 16) {
				attr(line1, "x2", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 8) {
				attr(line1, "y2", /*height*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(line0);
			if (detaching) detach(line1);
		}
	};
}

function create_fragment$9(ctx) {
	let pattern;
	let each0_anchor;
	let each1_anchor;
	let if_block0_anchor;
	let each_value_1 = /*xs*/ ctx[5];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*ys*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block0 = /*xLines*/ ctx[1] && create_if_block_1$1(ctx);
	let if_block1 = /*yLines*/ ctx[2] && create_if_block$1(ctx);

	return {
		c() {
			pattern = svg_element("pattern");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each1_anchor = empty();
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			attr(pattern, "id", /*id*/ ctx[0]);
			attr(pattern, "x", "0");
			attr(pattern, "y", "0");
			attr(pattern, "width", /*width*/ ctx[4]);
			attr(pattern, "height", /*height*/ ctx[3]);
			attr(pattern, "patternUnits", "userSpaceOnUse");
		},
		m(target, anchor) {
			insert(target, pattern, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(pattern, null);
			}

			append(pattern, each0_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(pattern, null);
			}

			append(pattern, each1_anchor);
			if (if_block0) if_block0.m(pattern, null);
			append(pattern, if_block0_anchor);
			if (if_block1) if_block1.m(pattern, null);
		},
		p(ctx, [dirty]) {
			if (dirty & /*xs, height*/ 40) {
				each_value_1 = /*xs*/ ctx[5];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(pattern, each0_anchor);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*ys, width*/ 80) {
				each_value = /*ys*/ ctx[6];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(pattern, each1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*xLines*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(pattern, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*yLines*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					if_block1.m(pattern, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*id*/ 1) {
				attr(pattern, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*width*/ 16) {
				attr(pattern, "width", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 8) {
				attr(pattern, "height", /*height*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(pattern);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let scaleX;
	let scaleY;
	let width;
	let height;
	let $context;
	let { id } = $$props;
	let { xLines = 1 } = $$props;
	let { yLines = 1 } = $$props;
	let { xSubdivisions = 1 } = $$props;
	let { ySubdivisions = 1 } = $$props;
	let context = getScaleContext();
	component_subscribe($$self, context, value => $$invalidate(12, $context = value));
	let xs = [];
	let ys = [];

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('xLines' in $$props) $$invalidate(1, xLines = $$props.xLines);
		if ('yLines' in $$props) $$invalidate(2, yLines = $$props.yLines);
		if ('xSubdivisions' in $$props) $$invalidate(8, xSubdivisions = $$props.xSubdivisions);
		if ('ySubdivisions' in $$props) $$invalidate(9, ySubdivisions = $$props.ySubdivisions);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$context*/ 4096) {
			$$invalidate(11, scaleX = $context.scaleX);
		}

		if ($$self.$$.dirty & /*$context*/ 4096) {
			$$invalidate(10, scaleY = $context.scaleY);
		}

		if ($$self.$$.dirty & /*scaleX, xLines*/ 2050) {
			$$invalidate(4, width = scaleX(xLines || 1));
		}

		if ($$self.$$.dirty & /*scaleY, yLines*/ 1028) {
			$$invalidate(3, height = -scaleY(yLines || 1));
		}

		if ($$self.$$.dirty & /*xSubdivisions, width*/ 272) {
			if (xSubdivisions && xSubdivisions > 1) {
				const pixelXDistance = width / xSubdivisions;
				$$invalidate(5, xs = range(0, width + pixelXDistance * 1.1, pixelXDistance).iter().toArray());
			}
		}

		if ($$self.$$.dirty & /*ySubdivisions, height*/ 520) {
			if (ySubdivisions && ySubdivisions > 1) {
				const pixelYDistance = height / ySubdivisions;
				$$invalidate(6, ys = range(0, height + pixelYDistance * 1.1, pixelYDistance).iter().toArray());
			}
		}
	};

	return [
		id,
		xLines,
		yLines,
		height,
		width,
		xs,
		ys,
		context,
		xSubdivisions,
		ySubdivisions,
		scaleY,
		scaleX,
		$context
	];
}

class GridPattern extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			id: 0,
			xLines: 1,
			yLines: 2,
			xSubdivisions: 8,
			ySubdivisions: 9
		});
	}
}

/* src/CartesianCoordinates.svelte generated by Svelte v3.42.4 */

function create_if_block_3(ctx) {
	let xlabels;
	let current;

	xlabels = new XLabels({
			props: {
				labelMaker: /*xAxisOptions*/ ctx[3].labels,
				separation: /*xAxisOptions*/ ctx[3].lines || 1
			}
		});

	return {
		c() {
			create_component(xlabels.$$.fragment);
		},
		m(target, anchor) {
			mount_component(xlabels, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const xlabels_changes = {};
			if (dirty & /*xAxisOptions*/ 8) xlabels_changes.labelMaker = /*xAxisOptions*/ ctx[3].labels;
			if (dirty & /*xAxisOptions*/ 8) xlabels_changes.separation = /*xAxisOptions*/ ctx[3].lines || 1;
			xlabels.$set(xlabels_changes);
		},
		i(local) {
			if (current) return;
			transition_in(xlabels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(xlabels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(xlabels, detaching);
		}
	};
}

// (44:0) {#if yAxis.labels}
function create_if_block_2(ctx) {
	let ylabels;
	let current;

	ylabels = new YLabels({
			props: {
				labelMaker: /*yAxisOptions*/ ctx[2].labels,
				separation: /*yAxisOptions*/ ctx[2].lines || 1
			}
		});

	return {
		c() {
			create_component(ylabels.$$.fragment);
		},
		m(target, anchor) {
			mount_component(ylabels, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const ylabels_changes = {};
			if (dirty & /*yAxisOptions*/ 4) ylabels_changes.labelMaker = /*yAxisOptions*/ ctx[2].labels;
			if (dirty & /*yAxisOptions*/ 4) ylabels_changes.separation = /*yAxisOptions*/ ctx[2].lines || 1;
			ylabels.$set(ylabels_changes);
		},
		i(local) {
			if (current) return;
			transition_in(ylabels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(ylabels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(ylabels, detaching);
		}
	};
}

// (51:0) {#if xAxisOptions.axis}
function create_if_block_1(ctx) {
	let line;
	let line_x__value;
	let line_x__value_1;
	let line_y__value;
	let line_y__value_1;

	return {
		c() {
			line = svg_element("line");
			attr(line, "x1", line_x__value = -10000000);
			attr(line, "x2", line_x__value_1 = 10000000);
			attr(line, "y1", line_y__value = 0);
			attr(line, "y2", line_y__value_1 = 0);
			attr(line, "class", "transform-y-to-center svelte-xqsvde");
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

// (61:0) {#if yAxisOptions.axis}
function create_if_block(ctx) {
	let line;
	let line_x__value;
	let line_x__value_1;
	let line_y__value;
	let line_y__value_1;

	return {
		c() {
			line = svg_element("line");
			attr(line, "x1", line_x__value = 0);
			attr(line, "x2", line_x__value_1 = 0);
			attr(line, "y1", line_y__value = -10000000);
			attr(line, "y2", line_y__value_1 = 10000000);
			attr(line, "class", "transform-x-to-center svelte-xqsvde");
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

function create_fragment$8(ctx) {
	let defs;
	let gridpattern;
	let t0;
	let rect;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block3_anchor;
	let current;

	gridpattern = new GridPattern({
			props: {
				id: /*id*/ ctx[4],
				xLines: /*xAxisOptions*/ ctx[3].lines,
				yLines: /*yAxisOptions*/ ctx[2].lines,
				xSubdivisions: /*xAxisOptions*/ ctx[3].subdivisions,
				ySubdivisions: /*yAxisOptions*/ ctx[2].subdivisions
			}
		});

	let if_block0 = /*xAxis*/ ctx[0].labels && create_if_block_3(ctx);
	let if_block1 = /*yAxis*/ ctx[1].labels && create_if_block_2(ctx);
	let if_block2 = /*xAxisOptions*/ ctx[3].axis && create_if_block_1();
	let if_block3 = /*yAxisOptions*/ ctx[2].axis && create_if_block();

	return {
		c() {
			defs = svg_element("defs");
			create_component(gridpattern.$$.fragment);
			t0 = space();
			rect = svg_element("rect");
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
			attr(rect, "fill", `url(#${/*id*/ ctx[4]})`);
			attr(rect, "x", -10000000);
			attr(rect, "y", -10000000);
			attr(rect, "width", 20000000);
			attr(rect, "height", 20000000);
		},
		m(target, anchor) {
			insert(target, defs, anchor);
			mount_component(gridpattern, defs, null);
			insert(target, t0, anchor);
			insert(target, rect, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert(target, if_block3_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const gridpattern_changes = {};
			if (dirty & /*xAxisOptions*/ 8) gridpattern_changes.xLines = /*xAxisOptions*/ ctx[3].lines;
			if (dirty & /*yAxisOptions*/ 4) gridpattern_changes.yLines = /*yAxisOptions*/ ctx[2].lines;
			if (dirty & /*xAxisOptions*/ 8) gridpattern_changes.xSubdivisions = /*xAxisOptions*/ ctx[3].subdivisions;
			if (dirty & /*yAxisOptions*/ 4) gridpattern_changes.ySubdivisions = /*yAxisOptions*/ ctx[2].subdivisions;
			gridpattern.$set(gridpattern_changes);

			if (/*xAxis*/ ctx[0].labels) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*xAxis*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*yAxis*/ ctx[1].labels) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*yAxis*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*xAxisOptions*/ ctx[3].axis) {
				if (if_block2) ; else {
					if_block2 = create_if_block_1();
					if_block2.c();
					if_block2.m(t4.parentNode, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*yAxisOptions*/ ctx[2].axis) {
				if (if_block3) ; else {
					if_block3 = create_if_block();
					if_block3.c();
					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(gridpattern.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(gridpattern.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(defs);
			destroy_component(gridpattern);
			if (detaching) detach(t0);
			if (detaching) detach(rect);
			if (detaching) detach(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(if_block3_anchor);
		}
	};
}

let incrementer = 0;
const defaultAxisOptions = { axis: true, lines: 1, labels: x => x };

function instance$8($$self, $$props, $$invalidate) {
	let xAxisOptions;
	let yAxisOptions;
	let { subdivisions = false } = $$props;
	let { xAxis = Object.assign({ subdivisions }, defaultAxisOptions) } = $$props;
	let { yAxis = Object.assign({ subdivisions }, defaultAxisOptions) } = $$props;
	const id = `visual-math-grid-${incrementer++}`;

	$$self.$$set = $$props => {
		if ('subdivisions' in $$props) $$invalidate(5, subdivisions = $$props.subdivisions);
		if ('xAxis' in $$props) $$invalidate(0, xAxis = $$props.xAxis);
		if ('yAxis' in $$props) $$invalidate(1, yAxis = $$props.yAxis);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*subdivisions, xAxis*/ 33) {
			$$invalidate(3, xAxisOptions = Object.assign(Object.assign({ subdivisions }, defaultAxisOptions), xAxis));
		}

		if ($$self.$$.dirty & /*subdivisions, yAxis*/ 34) {
			$$invalidate(2, yAxisOptions = Object.assign(Object.assign({ subdivisions }, defaultAxisOptions), yAxis));
		}
	};

	return [xAxis, yAxis, yAxisOptions, xAxisOptions, id, subdivisions];
}

class CartesianCoordinates extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { subdivisions: 5, xAxis: 0, yAxis: 1 });
	}
}

/* src/Ellipse.svelte generated by Svelte v3.42.4 */

function create_fragment$7(ctx) {
	let ellipse;
	let ellipse_cx_value;
	let ellipse_cy_value;
	let ellipse_rx_value;
	let ellipse_ry_value;
	let ellipse_stroke_dasharray_value;
	let ellipse_transform_value;
	let ellipse_style_value;

	let ellipse_levels = [
		{
			cx: ellipse_cx_value = /*center*/ ctx[0][0]
		},
		{
			cy: ellipse_cy_value = /*center*/ ctx[0][1]
		},
		{
			rx: ellipse_rx_value = Math.abs(/*radius*/ ctx[1][0])
		},
		{
			ry: ellipse_ry_value = Math.abs(/*radius*/ ctx[1][1])
		},
		{ "stroke-width": /*weight*/ ctx[4] },
		{
			"stroke-dasharray": ellipse_stroke_dasharray_value = /*strokeStyle*/ ctx[2] === "dashed" ? "4,3" : undefined
		},
		{
			transform: ellipse_transform_value = `${/*cssScale*/ ctx[8]} ${/*rotate*/ ctx[7]}`
		},
		/*$$restProps*/ ctx[10],
		{
			style: ellipse_style_value = `
    stroke: ${/*color*/ ctx[5]};
    fill: ${/*color*/ ctx[5]};
    fill-opacity: ${/*fillOpacity*/ ctx[6]};
    stroke-opacity: ${/*strokeOpacity*/ ctx[3]};
    ${/*$$restProps*/ ctx[10].style || ""}
  `
		}
	];

	let ellipse_data = {};

	for (let i = 0; i < ellipse_levels.length; i += 1) {
		ellipse_data = assign(ellipse_data, ellipse_levels[i]);
	}

	return {
		c() {
			ellipse = svg_element("ellipse");
			set_svg_attributes(ellipse, ellipse_data);
			toggle_class(ellipse, "svelte-cc8k9r", true);
		},
		m(target, anchor) {
			insert(target, ellipse, anchor);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(ellipse, ellipse_data = get_spread_update(ellipse_levels, [
				dirty & /*center*/ 1 && ellipse_cx_value !== (ellipse_cx_value = /*center*/ ctx[0][0]) && { cx: ellipse_cx_value },
				dirty & /*center*/ 1 && ellipse_cy_value !== (ellipse_cy_value = /*center*/ ctx[0][1]) && { cy: ellipse_cy_value },
				dirty & /*radius*/ 2 && ellipse_rx_value !== (ellipse_rx_value = Math.abs(/*radius*/ ctx[1][0])) && { rx: ellipse_rx_value },
				dirty & /*radius*/ 2 && ellipse_ry_value !== (ellipse_ry_value = Math.abs(/*radius*/ ctx[1][1])) && { ry: ellipse_ry_value },
				dirty & /*weight*/ 16 && { "stroke-width": /*weight*/ ctx[4] },
				dirty & /*strokeStyle*/ 4 && ellipse_stroke_dasharray_value !== (ellipse_stroke_dasharray_value = /*strokeStyle*/ ctx[2] === "dashed" ? "4,3" : undefined) && {
					"stroke-dasharray": ellipse_stroke_dasharray_value
				},
				dirty & /*cssScale, rotate*/ 384 && ellipse_transform_value !== (ellipse_transform_value = `${/*cssScale*/ ctx[8]} ${/*rotate*/ ctx[7]}`) && { transform: ellipse_transform_value },
				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
				dirty & /*color, fillOpacity, strokeOpacity, $$restProps*/ 1128 && ellipse_style_value !== (ellipse_style_value = `
    stroke: ${/*color*/ ctx[5]};
    fill: ${/*color*/ ctx[5]};
    fill-opacity: ${/*fillOpacity*/ ctx[6]};
    stroke-opacity: ${/*strokeOpacity*/ ctx[3]};
    ${/*$$restProps*/ ctx[10].style || ""}
  `) && { style: ellipse_style_value }
			]));

			toggle_class(ellipse, "svelte-cc8k9r", true);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(ellipse);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let cssScale;
	let rotate;

	const omit_props_names = [
		"center","radius","angle","strokeStyle","strokeOpacity","weight","color","fillOpacity"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $scaleContext;
	let { center = vec2.fromValues(0, 0) } = $$props;
	let { radius = vec2.fromValues(1, 1) } = $$props;
	let { angle = 0 } = $$props;
	let { strokeStyle = "solid" } = $$props;
	let { strokeOpacity = 1.0 } = $$props;
	let { weight = 2 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { fillOpacity = 0.15 } = $$props;
	let scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(12, $scaleContext = value));

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('center' in $$new_props) $$invalidate(0, center = $$new_props.center);
		if ('radius' in $$new_props) $$invalidate(1, radius = $$new_props.radius);
		if ('angle' in $$new_props) $$invalidate(11, angle = $$new_props.angle);
		if ('strokeStyle' in $$new_props) $$invalidate(2, strokeStyle = $$new_props.strokeStyle);
		if ('strokeOpacity' in $$new_props) $$invalidate(3, strokeOpacity = $$new_props.strokeOpacity);
		if ('weight' in $$new_props) $$invalidate(4, weight = $$new_props.weight);
		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ('fillOpacity' in $$new_props) $$invalidate(6, fillOpacity = $$new_props.fillOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 4096) {
			$$invalidate(8, cssScale = $scaleContext.cssScale);
		}

		if ($$self.$$.dirty & /*angle, center*/ 2049) {
			$$invalidate(7, rotate = `rotate(${angle * 180 / Math.PI} ${center[0]} ${center[1]})`);
		}
	};

	return [
		center,
		radius,
		strokeStyle,
		strokeOpacity,
		weight,
		color,
		fillOpacity,
		rotate,
		cssScale,
		scaleContext,
		$$restProps,
		angle,
		$scaleContext
	];
}

class Ellipse extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			center: 0,
			radius: 1,
			angle: 11,
			strokeStyle: 2,
			strokeOpacity: 3,
			weight: 4,
			color: 5,
			fillOpacity: 6
		});
	}
}

/* src/Circle.svelte generated by Svelte v3.42.4 */

function create_fragment$6(ctx) {
	let ellipse;
	let current;

	const ellipse_spread_levels = [
		{ center: /*center*/ ctx[0] },
		{ radius: /*ellipseRadius*/ ctx[7] },
		{ angle: /*angle*/ ctx[1] },
		{ strokeStyle: /*strokeStyle*/ ctx[2] },
		{ strokeOpacity: /*strokeOpacity*/ ctx[3] },
		{ weight: /*weight*/ ctx[4] },
		{ color: /*color*/ ctx[5] },
		{ fillOpacity: /*fillOpacity*/ ctx[6] },
		/*$$restProps*/ ctx[8]
	];

	let ellipse_props = {};

	for (let i = 0; i < ellipse_spread_levels.length; i += 1) {
		ellipse_props = assign(ellipse_props, ellipse_spread_levels[i]);
	}

	ellipse = new Ellipse({ props: ellipse_props });

	return {
		c() {
			create_component(ellipse.$$.fragment);
		},
		m(target, anchor) {
			mount_component(ellipse, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const ellipse_changes = (dirty & /*center, ellipseRadius, angle, strokeStyle, strokeOpacity, weight, color, fillOpacity, $$restProps*/ 511)
			? get_spread_update(ellipse_spread_levels, [
					dirty & /*center*/ 1 && { center: /*center*/ ctx[0] },
					dirty & /*ellipseRadius*/ 128 && { radius: /*ellipseRadius*/ ctx[7] },
					dirty & /*angle*/ 2 && { angle: /*angle*/ ctx[1] },
					dirty & /*strokeStyle*/ 4 && { strokeStyle: /*strokeStyle*/ ctx[2] },
					dirty & /*strokeOpacity*/ 8 && { strokeOpacity: /*strokeOpacity*/ ctx[3] },
					dirty & /*weight*/ 16 && { weight: /*weight*/ ctx[4] },
					dirty & /*color*/ 32 && { color: /*color*/ ctx[5] },
					dirty & /*fillOpacity*/ 64 && { fillOpacity: /*fillOpacity*/ ctx[6] },
					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
				])
			: {};

			ellipse.$set(ellipse_changes);
		},
		i(local) {
			if (current) return;
			transition_in(ellipse.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(ellipse.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(ellipse, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"center","radius","angle","strokeStyle","strokeOpacity","weight","color","fillOpacity"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { center = vec2.fromValues(0, 0) } = $$props;
	let { radius = 1 } = $$props;
	let { angle = 0 } = $$props;
	let { strokeStyle = "solid" } = $$props;
	let { strokeOpacity = 1.0 } = $$props;
	let { weight = 2 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { fillOpacity = 0.15 } = $$props;
	let ellipseRadius = vec2.fromValues(radius, radius);

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('center' in $$new_props) $$invalidate(0, center = $$new_props.center);
		if ('radius' in $$new_props) $$invalidate(9, radius = $$new_props.radius);
		if ('angle' in $$new_props) $$invalidate(1, angle = $$new_props.angle);
		if ('strokeStyle' in $$new_props) $$invalidate(2, strokeStyle = $$new_props.strokeStyle);
		if ('strokeOpacity' in $$new_props) $$invalidate(3, strokeOpacity = $$new_props.strokeOpacity);
		if ('weight' in $$new_props) $$invalidate(4, weight = $$new_props.weight);
		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ('fillOpacity' in $$new_props) $$invalidate(6, fillOpacity = $$new_props.fillOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ellipseRadius, radius*/ 640) {
			$$invalidate(7, ellipseRadius = vec2.set(ellipseRadius, radius, radius));
		}
	};

	return [
		center,
		angle,
		strokeStyle,
		strokeOpacity,
		weight,
		color,
		fillOpacity,
		ellipseRadius,
		$$restProps,
		radius
	];
}

class Circle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			center: 0,
			radius: 9,
			angle: 1,
			strokeStyle: 2,
			strokeOpacity: 3,
			weight: 4,
			color: 5,
			fillOpacity: 6
		});
	}
}

/* src/MovablePoint.svelte generated by Svelte v3.42.4 */

function create_fragment$5(ctx) {
	let g;
	let circle0;
	let circle0_cx_value;
	let circle0_cy_value;
	let circle1;
	let circle1_cx_value;
	let circle1_cy_value;

	return {
		c() {
			g = svg_element("g");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr(circle0, "cx", circle0_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]));
			attr(circle0, "cy", circle0_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]));
			attr(circle0, "r", 30);
			attr(circle0, "fill", "transparent");
			attr(circle1, "cx", circle1_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]));
			attr(circle1, "cy", circle1_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]));
			attr(circle1, "r", 6);
			attr(circle1, "fill", /*color*/ ctx[0]);
			attr(circle1, "stroke", /*color*/ ctx[0]);
			attr(circle1, "stroke-opacity", 0.25);
			attr(circle1, "tabindex", 0);
			toggle_class(circle1, "draggable", /*dragging*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, g, anchor);
			append(g, circle0);
			append(g, circle1);
			/*g_binding*/ ctx[15](g);
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaleX, display*/ 34 && circle0_cx_value !== (circle0_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]))) {
				attr(circle0, "cx", circle0_cx_value);
			}

			if (dirty & /*scaleY, display*/ 18 && circle0_cy_value !== (circle0_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]))) {
				attr(circle0, "cy", circle0_cy_value);
			}

			if (dirty & /*scaleX, display*/ 34 && circle1_cx_value !== (circle1_cx_value = /*scaleX*/ ctx[5](/*display*/ ctx[1][0]))) {
				attr(circle1, "cx", circle1_cx_value);
			}

			if (dirty & /*scaleY, display*/ 18 && circle1_cy_value !== (circle1_cy_value = /*scaleY*/ ctx[4](/*display*/ ctx[1][1]))) {
				attr(circle1, "cy", circle1_cy_value);
			}

			if (dirty & /*color*/ 1) {
				attr(circle1, "fill", /*color*/ ctx[0]);
			}

			if (dirty & /*color*/ 1) {
				attr(circle1, "stroke", /*color*/ ctx[0]);
			}

			if (dirty & /*dragging*/ 8) {
				toggle_class(circle1, "draggable", /*dragging*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(g);
			/*g_binding*/ ctx[15](null);
		}
	};
}

const VEC2_0$3 = vec2.create();

function instance$5($$self, $$props, $$invalidate) {
	let scaleX;
	let scaleY;
	let inversePixelMatrix;
	let onDrag;
	let $scaleContext;
	let { point = vec2.create() } = $$props;
	let { color = "var(--visual-math-blue)" } = $$props;
	let { transform = mat2d.create() } = $$props;
	let { constrain = undefined } = $$props;
	let intialPoint = vec2.fromValues(point[0], point[1]);
	let constraintFunction = point => point;
	point = constraintFunction(point);
	let scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(14, $scaleContext = value));
	let display = vec2.create();
	let inverseTransform = mat2d.create();
	let element;
	let startPoint = vec2.create();
	let dragging = false;

	onMount(() => {
		const dragGesture = new DragGesture(element, onDrag);

		return () => {
			dragGesture.destroy();
		};
	});

	function g_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$props => {
		if ('point' in $$props) $$invalidate(7, point = $$props.point);
		if ('color' in $$props) $$invalidate(0, color = $$props.color);
		if ('transform' in $$props) $$invalidate(8, transform = $$props.transform);
		if ('constrain' in $$props) $$invalidate(9, constrain = $$props.constrain);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*constrain*/ 512) {
			if (constrain === "horizontal") {
				$$invalidate(10, constraintFunction = ([x, _y]) => [x, intialPoint[1]]);
			} else if (constrain === "vertical") {
				$$invalidate(10, constraintFunction = ([_x, y]) => [intialPoint[0], y]);
			} else if (typeof constrain === "function") {
				$$invalidate(10, constraintFunction = constrain);
			}
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(5, scaleX = $scaleContext.scaleX);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(4, scaleY = $scaleContext.scaleY);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 16384) {
			$$invalidate(13, inversePixelMatrix = $scaleContext.inversePixelMatrix);
		}

		if ($$self.$$.dirty & /*inverseTransform, transform*/ 2304) {
			$$invalidate(11, inverseTransform = mat2d.invert(inverseTransform, transform));
		}

		if ($$self.$$.dirty & /*inversePixelMatrix, startPoint, point, transform, inverseTransform, constraintFunction*/ 15744) {
			onDrag = state => {
				var _a;

				(_a = state.event) === null || _a === void 0
				? void 0
				: _a.stopPropagation();

				$$invalidate(3, dragging = state.down);
				const movement = vec2.transformMat2d(VEC2_0$3, state.movement, inversePixelMatrix);

				if (state.first) {
					$$invalidate(12, startPoint = vec2.transformMat2d(startPoint, point, transform));
				}

				vec2.add(point, startPoint, movement);
				vec2.transformMat2d(point, point, inverseTransform);
				$$invalidate(7, point = constraintFunction(point));
			};
		}

		if ($$self.$$.dirty & /*display, point, transform*/ 386) {
			$$invalidate(1, display = vec2.transformMat2d(display, point, transform));
		}
	};

	return [
		color,
		display,
		element,
		dragging,
		scaleY,
		scaleX,
		scaleContext,
		point,
		transform,
		constrain,
		constraintFunction,
		inverseTransform,
		startPoint,
		inversePixelMatrix,
		$scaleContext,
		g_binding
	];
}

class MovablePoint extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			point: 7,
			color: 0,
			transform: 8,
			constrain: 9
		});
	}
}

/* src/Point.svelte generated by Svelte v3.42.4 */

function create_fragment$4(ctx) {
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_r_value;
	let circle_style_value;

	let circle_levels = [
		{
			cx: circle_cx_value = /*scaleX*/ ctx[4](/*point*/ ctx[0][0])
		},
		{
			cy: circle_cy_value = /*scaleY*/ ctx[3](/*point*/ ctx[0][1])
		},
		{ r: circle_r_value = 6 },
		/*$$restProps*/ ctx[6],
		{
			style: circle_style_value = `fill: ${/*color*/ ctx[1]}; opacity: ${/*opacity*/ ctx[2]}; ${/*$$restProps*/ ctx[6].style}`
		}
	];

	let circle_data = {};

	for (let i = 0; i < circle_levels.length; i += 1) {
		circle_data = assign(circle_data, circle_levels[i]);
	}

	return {
		c() {
			circle = svg_element("circle");
			set_svg_attributes(circle, circle_data);
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, [dirty]) {
			set_svg_attributes(circle, circle_data = get_spread_update(circle_levels, [
				dirty & /*scaleX, point*/ 17 && circle_cx_value !== (circle_cx_value = /*scaleX*/ ctx[4](/*point*/ ctx[0][0])) && { cx: circle_cx_value },
				dirty & /*scaleY, point*/ 9 && circle_cy_value !== (circle_cy_value = /*scaleY*/ ctx[3](/*point*/ ctx[0][1])) && { cy: circle_cy_value },
				{ r: circle_r_value },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				dirty & /*color, opacity, $$restProps*/ 70 && circle_style_value !== (circle_style_value = `fill: ${/*color*/ ctx[1]}; opacity: ${/*opacity*/ ctx[2]}; ${/*$$restProps*/ ctx[6].style}`) && { style: circle_style_value }
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let scaleX;
	let scaleY;
	const omit_props_names = ["point","color","opacity"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let $scaleContext;
	let { point = vec2.create() } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { opacity = 1 } = $$props;
	const scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(7, $scaleContext = value));

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('point' in $$new_props) $$invalidate(0, point = $$new_props.point);
		if ('color' in $$new_props) $$invalidate(1, color = $$new_props.color);
		if ('opacity' in $$new_props) $$invalidate(2, opacity = $$new_props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 128) {
			$$invalidate(4, scaleX = $scaleContext.scaleX);
		}

		if ($$self.$$.dirty & /*$scaleContext*/ 128) {
			$$invalidate(3, scaleY = $scaleContext.scaleY);
		}
	};

	return [
		point,
		color,
		opacity,
		scaleY,
		scaleX,
		scaleContext,
		$$restProps,
		$scaleContext
	];
}

class Point extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { point: 0, color: 1, opacity: 2 });
	}
}

/* src/ThroughPoints.svelte generated by Svelte v3.42.4 */

function create_fragment$3(ctx) {
	let line;
	let line_x__value;
	let line_y__value;
	let line_x__value_1;
	let line_y__value_1;
	let line_style_value;
	let line_stroke_dasharray_value;

	return {
		c() {
			line = svg_element("line");
			attr(line, "x1", line_x__value = /*scaledPoint1*/ ctx[4][0]);
			attr(line, "y1", line_y__value = /*scaledPoint1*/ ctx[4][1]);
			attr(line, "x2", line_x__value_1 = /*scaledPoint2*/ ctx[5][0]);
			attr(line, "y2", line_y__value_1 = /*scaledPoint2*/ ctx[5][1]);
			attr(line, "style", line_style_value = `stroke: ${/*color*/ ctx[0]}`);
			attr(line, "stroke-width", /*weight*/ ctx[2]);
			attr(line, "opacity", /*opacity*/ ctx[3]);
			attr(line, "stroke-dasharray", line_stroke_dasharray_value = /*style*/ ctx[1] === "dashed" ? "4,3" : undefined);
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*scaledPoint1*/ 16 && line_x__value !== (line_x__value = /*scaledPoint1*/ ctx[4][0])) {
				attr(line, "x1", line_x__value);
			}

			if (dirty & /*scaledPoint1*/ 16 && line_y__value !== (line_y__value = /*scaledPoint1*/ ctx[4][1])) {
				attr(line, "y1", line_y__value);
			}

			if (dirty & /*scaledPoint2*/ 32 && line_x__value_1 !== (line_x__value_1 = /*scaledPoint2*/ ctx[5][0])) {
				attr(line, "x2", line_x__value_1);
			}

			if (dirty & /*scaledPoint2*/ 32 && line_y__value_1 !== (line_y__value_1 = /*scaledPoint2*/ ctx[5][1])) {
				attr(line, "y2", line_y__value_1);
			}

			if (dirty & /*color*/ 1 && line_style_value !== (line_style_value = `stroke: ${/*color*/ ctx[0]}`)) {
				attr(line, "style", line_style_value);
			}

			if (dirty & /*weight*/ 4) {
				attr(line, "stroke-width", /*weight*/ ctx[2]);
			}

			if (dirty & /*opacity*/ 8) {
				attr(line, "opacity", /*opacity*/ ctx[3]);
			}

			if (dirty & /*style*/ 2 && line_stroke_dasharray_value !== (line_stroke_dasharray_value = /*style*/ ctx[1] === "dashed" ? "4,3" : undefined)) {
				attr(line, "stroke-dasharray", line_stroke_dasharray_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

const VEC2_0$2 = vec2.create();

function instance$3($$self, $$props, $$invalidate) {
	let pixelMatrix;
	let $scaleContext;
	let { point1 = vec2.create() } = $$props;
	let { point2 = vec2.create() } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { style = "solid" } = $$props;
	let { weight = 2 } = $$props;
	let { opacity = 1 } = $$props;
	const scaleContext = getScaleContext();
	component_subscribe($$self, scaleContext, value => $$invalidate(11, $scaleContext = value));
	let segment = vec2.create();
	let scaledPoint1 = vec2.create();
	let scaledPoint2 = vec2.create();

	$$self.$$set = $$props => {
		if ('point1' in $$props) $$invalidate(7, point1 = $$props.point1);
		if ('point2' in $$props) $$invalidate(8, point2 = $$props.point2);
		if ('color' in $$props) $$invalidate(0, color = $$props.color);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('weight' in $$props) $$invalidate(2, weight = $$props.weight);
		if ('opacity' in $$props) $$invalidate(3, opacity = $$props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$scaleContext*/ 2048) {
			$$invalidate(10, pixelMatrix = $scaleContext.pixelMatrix);
		}

		if ($$self.$$.dirty & /*segment, point2, point1*/ 896) {
			$$invalidate(9, segment = vec2.scale(segment, vec2.normalize(segment, vec2.sub(VEC2_0$2, point2, point1)), 100000));
		}

		if ($$self.$$.dirty & /*scaledPoint1, point1, segment, pixelMatrix*/ 1680) {
			$$invalidate(4, scaledPoint1 = vec2.transformMat2d(scaledPoint1, vec2.sub(VEC2_0$2, point1, segment), pixelMatrix));
		}

		if ($$self.$$.dirty & /*scaledPoint2, point2, segment, pixelMatrix*/ 1824) {
			$$invalidate(5, scaledPoint2 = vec2.transformMat2d(scaledPoint2, vec2.add(VEC2_0$2, point2, segment), pixelMatrix));
		}
	};

	return [
		color,
		style,
		weight,
		opacity,
		scaledPoint1,
		scaledPoint2,
		scaleContext,
		point1,
		point2,
		segment,
		pixelMatrix,
		$scaleContext
	];
}

class ThroughPoints extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			point1: 7,
			point2: 8,
			color: 0,
			style: 1,
			weight: 2,
			opacity: 3
		});
	}
}

/* src/PointAngle.svelte generated by Svelte v3.42.4 */

function create_fragment$2(ctx) {
	let throughpoints;
	let current;

	throughpoints = new ThroughPoints({
			props: {
				point1: /*point*/ ctx[0],
				point2: /*point2*/ ctx[5],
				color: /*color*/ ctx[1],
				opacity: /*opacity*/ ctx[4],
				style: /*style*/ ctx[2],
				weight: /*weight*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(throughpoints.$$.fragment);
		},
		m(target, anchor) {
			mount_component(throughpoints, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const throughpoints_changes = {};
			if (dirty & /*point*/ 1) throughpoints_changes.point1 = /*point*/ ctx[0];
			if (dirty & /*point2*/ 32) throughpoints_changes.point2 = /*point2*/ ctx[5];
			if (dirty & /*color*/ 2) throughpoints_changes.color = /*color*/ ctx[1];
			if (dirty & /*opacity*/ 16) throughpoints_changes.opacity = /*opacity*/ ctx[4];
			if (dirty & /*style*/ 4) throughpoints_changes.style = /*style*/ ctx[2];
			if (dirty & /*weight*/ 8) throughpoints_changes.weight = /*weight*/ ctx[3];
			throughpoints.$set(throughpoints_changes);
		},
		i(local) {
			if (current) return;
			transition_in(throughpoints.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(throughpoints.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(throughpoints, detaching);
		}
	};
}

const VEC2_0$1 = vec2.create();
const ZERO = vec2.create();
const RIGHT = vec2.fromValues(1, 0);

function instance$2($$self, $$props, $$invalidate) {
	let { point = vec2.create() } = $$props;
	let { angle = 0 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { style = "solid" } = $$props;
	let { weight = 2 } = $$props;
	let { opacity = 1 } = $$props;
	let point2 = vec2.create();

	$$self.$$set = $$props => {
		if ('point' in $$props) $$invalidate(0, point = $$props.point);
		if ('angle' in $$props) $$invalidate(6, angle = $$props.angle);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('weight' in $$props) $$invalidate(3, weight = $$props.weight);
		if ('opacity' in $$props) $$invalidate(4, opacity = $$props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*point2, point, angle*/ 97) {
			$$invalidate(5, point2 = vec2.add(point2, point, vec2.rotate(VEC2_0$1, RIGHT, ZERO, angle)));
		}
	};

	return [point, color, style, weight, opacity, point2, angle];
}

class PointAngle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			point: 0,
			angle: 6,
			color: 1,
			style: 2,
			weight: 3,
			opacity: 4
		});
	}
}

/* src/PointSlope.svelte generated by Svelte v3.42.4 */

function create_fragment$1(ctx) {
	let pointangle;
	let current;

	pointangle = new PointAngle({
			props: {
				point: /*point*/ ctx[0],
				angle: /*angle*/ ctx[5],
				color: /*color*/ ctx[1],
				opacity: /*opacity*/ ctx[4],
				style: /*style*/ ctx[2],
				weight: /*weight*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(pointangle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pointangle, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const pointangle_changes = {};
			if (dirty & /*point*/ 1) pointangle_changes.point = /*point*/ ctx[0];
			if (dirty & /*angle*/ 32) pointangle_changes.angle = /*angle*/ ctx[5];
			if (dirty & /*color*/ 2) pointangle_changes.color = /*color*/ ctx[1];
			if (dirty & /*opacity*/ 16) pointangle_changes.opacity = /*opacity*/ ctx[4];
			if (dirty & /*style*/ 4) pointangle_changes.style = /*style*/ ctx[2];
			if (dirty & /*weight*/ 8) pointangle_changes.weight = /*weight*/ ctx[3];
			pointangle.$set(pointangle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pointangle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pointangle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pointangle, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { point = vec2.create() } = $$props;
	let { slope = 0 } = $$props;
	let { color = "var(--visual-math-fg)" } = $$props;
	let { style = "solid" } = $$props;
	let { weight = 2 } = $$props;
	let { opacity = 1 } = $$props;
	let angle = Math.atan(slope);

	$$self.$$set = $$props => {
		if ('point' in $$props) $$invalidate(0, point = $$props.point);
		if ('slope' in $$props) $$invalidate(6, slope = $$props.slope);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('weight' in $$props) $$invalidate(3, weight = $$props.weight);
		if ('opacity' in $$props) $$invalidate(4, opacity = $$props.opacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*slope*/ 64) {
			$$invalidate(5, angle = Math.atan(slope));
		}
	};

	return [point, color, style, weight, opacity, angle, slope];
}

class PointSlope extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			point: 0,
			slope: 6,
			color: 1,
			style: 2,
			weight: 3,
			opacity: 4
		});
	}
}

/* src/VisualMath.svelte generated by Svelte v3.42.4 */

function create_fragment(ctx) {
	let div;
	let svg;
	let svg_viewBox_value;
	let svg_style_value;
	let div_style_value;
	let div_resize_listener;
	let current;
	const default_slot_template = /*#slots*/ ctx[38].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			attr(svg, "width", /*actualWidth*/ ctx[2]);
			attr(svg, "height", /*actualHeight*/ ctx[3]);
			attr(svg, "viewBox", svg_viewBox_value = `${-/*mapX*/ ctx[5](0)} ${-/*mapY*/ ctx[4](0)} ${/*actualWidth*/ ctx[2]} ${/*actualHeight*/ ctx[3]}`);
			attr(svg, "preserveAspectRatio", "xMidYMin");
			attr(svg, "style", svg_style_value = `width: ${/*width*/ ctx[0]}; touch-action: ${/*pan*/ ctx[1] ? "none" : "auto"};`);
			attr(div, "class", "visual-math svelte-5trppw");
			attr(div, "style", div_style_value = `width: ${/*desiredCssWidth*/ ctx[8]}; height: ${/*desiredCssHeight*/ ctx[7]}`);
			add_render_callback(() => /*div_elementresize_handler*/ ctx[40].call(div));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			/*div_binding*/ ctx[39](div);
			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[40].bind(div));
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*actualWidth*/ 4) {
				attr(svg, "width", /*actualWidth*/ ctx[2]);
			}

			if (!current || dirty[0] & /*actualHeight*/ 8) {
				attr(svg, "height", /*actualHeight*/ ctx[3]);
			}

			if (!current || dirty[0] & /*mapX, mapY, actualWidth, actualHeight*/ 60 && svg_viewBox_value !== (svg_viewBox_value = `${-/*mapX*/ ctx[5](0)} ${-/*mapY*/ ctx[4](0)} ${/*actualWidth*/ ctx[2]} ${/*actualHeight*/ ctx[3]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			if (!current || dirty[0] & /*width, pan*/ 3 && svg_style_value !== (svg_style_value = `width: ${/*width*/ ctx[0]}; touch-action: ${/*pan*/ ctx[1] ? "none" : "auto"};`)) {
				attr(svg, "style", svg_style_value);
			}

			if (!current || dirty[0] & /*desiredCssWidth, desiredCssHeight*/ 384 && div_style_value !== (div_style_value = `width: ${/*desiredCssWidth*/ ctx[8]}; height: ${/*desiredCssHeight*/ ctx[7]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[39](null);
			div_resize_listener();
		}
	};
}

const VEC2_0 = vec2.create();

function getMouseWheelDirection(e) {
	if (typeof e.detail == "number" && e.detail !== 0) {
		if (e.detail > 0) {
			return -1;
		} else if (e.detail < 0) {
			return 1;
		}
	} else if (typeof e.wheelDelta === "number") {
		if (e.wheelDelta < 0) {
			return -1;
		} else if (e.wheelDelta > 0) {
			return 1;
		}
	}

	return undefined;
}

let base = 2;

function instance($$self, $$props, $$invalidate) {
	let desiredCssWidth;
	let desiredCssHeight;
	let mapX;
	let mapY;
	let scaleX;
	let scaleY;
	let unscaleX;
	let unscaleY;
	let cssScale;
	let xSpan;
	let xStep;
	let xLowerBound;
	let xUpperBound;
	let ySpan;
	let yStep;
	let yLowerBound;
	let yUpperBound;
	let onDrag;
	let onMouseWheel;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { width = 500 } = $$props;
	let { height = 500 } = $$props;
	let { pan = true } = $$props;
	let { zoom = true } = $$props;
	let { xAxisExtent = vec2.fromValues(-5.5, 5.5) } = $$props;
	let { yAxisExtent = vec2.fromValues(-5.5, 5.5) } = $$props;
	let actualWidth = typeof width === "number" ? width : 500;
	let actualHeight = typeof height === "number" ? height : 500;
	let zoomAmount = Math.min(xAxisExtent[1] - xAxisExtent[0], yAxisExtent[1] - yAxisExtent[0]);
	let offset = vec2.fromValues(0, 0);
	let min = vec2.fromValues(xAxisExtent[0], yAxisExtent[0]);
	let max = vec2.fromValues(xAxisExtent[1], yAxisExtent[1]);
	let span = vec2.create();
	let pixelMatrix = mat2d.create();
	let inversePixelMatrix = mat2d.create();
	let xPanes = [];
	let yPanes = [];
	let xPaneRange = vec2.create();
	let yPaneRange = vec2.create();
	let panesContext = writable({ xPanes, yPanes, xPaneRange, yPaneRange });
	setPanesContext(panesContext);

	let coordinateContext = writable({
		min,
		max,
		width: actualWidth,
		height: actualHeight
	});

	setCoordinateContext(coordinateContext);

	let scaleContext = writable({
		zoomAmount,
		scaleX,
		scaleY,
		span,
		pixelMatrix,
		inversePixelMatrix,
		cssScale
	});

	setScaleContext(scaleContext);
	let mapContext = writable({ mapX, mapY });
	setMapContext(mapContext);
	let element;

	onMount(() => {
		const dragGesture = new DragGesture(element, onDrag),
			wheelGesture = new WheelGesture(element, onMouseWheel);

		return () => {
			dragGesture.destroy();
			wheelGesture.destroy();
		};
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(6, element);
		});
	}

	function div_elementresize_handler() {
		actualWidth = this.offsetWidth;
		actualHeight = this.offsetHeight;
		$$invalidate(2, actualWidth);
		$$invalidate(3, actualHeight);
	}

	$$self.$$set = $$props => {
		if ('width' in $$props) $$invalidate(0, width = $$props.width);
		if ('height' in $$props) $$invalidate(11, height = $$props.height);
		if ('pan' in $$props) $$invalidate(1, pan = $$props.pan);
		if ('zoom' in $$props) $$invalidate(12, zoom = $$props.zoom);
		if ('xAxisExtent' in $$props) $$invalidate(9, xAxisExtent = $$props.xAxisExtent);
		if ('yAxisExtent' in $$props) $$invalidate(10, yAxisExtent = $$props.yAxisExtent);
		if ('$$scope' in $$props) $$invalidate(37, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*width*/ 1) {
			$$invalidate(8, desiredCssWidth = width === "auto" ? "100%" : `${width}px`);
		}

		if ($$self.$$.dirty[0] & /*height*/ 2048) {
			$$invalidate(7, desiredCssHeight = height === "auto" ? "100%" : `${height}px`);
		}

		if ($$self.$$.dirty[0] & /*zoom, zoomAmount, xAxisExtent, yAxisExtent*/ 13824) {
			onMouseWheel = state => {
				if (!zoom || state.last) {
					return;
				}

				const wheelDirection = getMouseWheelDirection(state.event);

				if (wheelDirection && (zoomAmount > 3 || wheelDirection < 0)) {
					$$invalidate(9, xAxisExtent = vec2.set(xAxisExtent, xAxisExtent[0] + wheelDirection, xAxisExtent[1] - wheelDirection));
					$$invalidate(10, yAxisExtent = vec2.set(yAxisExtent, yAxisExtent[0] + wheelDirection, yAxisExtent[1] - wheelDirection));
					$$invalidate(13, zoomAmount = Math.min(xAxisExtent[1] - xAxisExtent[0], yAxisExtent[1] - yAxisExtent[0]));
				}
			};
		}

		if ($$self.$$.dirty[0] & /*actualWidth, actualHeight, zoomAmount*/ 8204) {
			{
				const aspect = actualWidth / actualHeight,
					halfZoomAmount = zoomAmount * 0.5,
					newZoomAmount = zoomAmount * aspect,
					halfNewZoomAmount = newZoomAmount * 0.5;

				$$invalidate(9, xAxisExtent[0] = -halfNewZoomAmount, xAxisExtent);
				$$invalidate(9, xAxisExtent[1] = halfNewZoomAmount, xAxisExtent);
				$$invalidate(10, yAxisExtent[0] = -halfZoomAmount, yAxisExtent);
				$$invalidate(10, yAxisExtent[1] = halfZoomAmount, yAxisExtent);
			}
		}

		if ($$self.$$.dirty[0] & /*pan, actualWidth, xAxisExtent, actualHeight, yAxisExtent*/ 1550) {
			onDrag = state => {
				if (!pan) {
					return;
				}

				$$invalidate(14, offset[0] = -state.offset[0] / actualWidth * (xAxisExtent[1] - xAxisExtent[0]), offset);
				$$invalidate(14, offset[1] = -state.offset[1] / actualHeight * (yAxisExtent[1] - yAxisExtent[0]), offset);
			};
		}

		if ($$self.$$.dirty[0] & /*min, offset, xAxisExtent, yAxisExtent*/ 50688) {
			$$invalidate(15, min = vec2.add(min, offset, vec2.set(VEC2_0, xAxisExtent[0], yAxisExtent[0])));
		}

		if ($$self.$$.dirty[0] & /*max, offset, xAxisExtent, yAxisExtent*/ 83456) {
			$$invalidate(16, max = vec2.add(max, offset, vec2.set(VEC2_0, xAxisExtent[1], yAxisExtent[1])));
		}

		if ($$self.$$.dirty[0] & /*min, max, actualWidth*/ 98308) {
			$$invalidate(5, mapX = x => (x - min[0]) / (max[0] - min[0]) * actualWidth);
		}

		if ($$self.$$.dirty[0] & /*min, max, actualHeight*/ 98312) {
			$$invalidate(4, mapY = y => (y - min[1]) / (max[1] - min[1]) * actualHeight);
		}

		if ($$self.$$.dirty[0] & /*span, max, min*/ 229376) {
			$$invalidate(17, span = vec2.sub(span, max, min));
		}

		if ($$self.$$.dirty[0] & /*span, actualWidth*/ 131076) {
			$$invalidate(26, scaleX = x => x / span[0] * actualWidth);
		}

		if ($$self.$$.dirty[0] & /*span, actualHeight*/ 131080) {
			$$invalidate(25, scaleY = y => -y / span[1] * actualHeight);
		}

		if ($$self.$$.dirty[0] & /*max, min*/ 98304) {
			$$invalidate(34, xSpan = max[0] - min[0]);
		}

		if ($$self.$$.dirty[0] & /*actualWidth*/ 4 | $$self.$$.dirty[1] & /*xSpan*/ 8) {
			$$invalidate(36, unscaleX = x => x / actualWidth * xSpan);
		}

		if ($$self.$$.dirty[0] & /*max, min*/ 98304) {
			$$invalidate(30, ySpan = max[1] - min[1]);
		}

		if ($$self.$$.dirty[0] & /*actualHeight, ySpan*/ 1073741832) {
			$$invalidate(35, unscaleY = y => -y / actualHeight * ySpan);
		}

		if ($$self.$$.dirty[0] & /*pixelMatrix, scaleX, scaleY*/ 100925440) {
			$$invalidate(18, pixelMatrix = mat2d.fromScaling(pixelMatrix, vec2.set(VEC2_0, scaleX(1), scaleY(1))));
		}

		if ($$self.$$.dirty[0] & /*inversePixelMatrix*/ 524288 | $$self.$$.dirty[1] & /*unscaleX, unscaleY*/ 48) {
			$$invalidate(19, inversePixelMatrix = mat2d.fromScaling(inversePixelMatrix, vec2.set(VEC2_0, unscaleX(1), unscaleY(1))));
		}

		if ($$self.$$.dirty[0] & /*scaleX, scaleY*/ 100663296) {
			$$invalidate(24, cssScale = `scale(${scaleX(1)} ${scaleY(1)})`);
		}

		if ($$self.$$.dirty[1] & /*xSpan*/ 8) {
			$$invalidate(33, xStep = Math.pow(base, Math.round(Math.log10(xSpan) / Math.log10(base))));
		}

		if ($$self.$$.dirty[0] & /*min*/ 32768 | $$self.$$.dirty[1] & /*xStep*/ 4) {
			$$invalidate(32, xLowerBound = Math.floor(min[0] / xStep) * xStep);
		}

		if ($$self.$$.dirty[0] & /*max*/ 65536 | $$self.$$.dirty[1] & /*xStep*/ 4) {
			$$invalidate(31, xUpperBound = Math.ceil(max[0] / xStep) * xStep);
		}

		if ($$self.$$.dirty[1] & /*xLowerBound, xUpperBound, xStep*/ 7) {
			$$invalidate(20, xPanes = range(xLowerBound, xUpperBound, xStep).iter().map(xMin => vec2.fromValues(xMin, xMin + xStep)).toArray());
		}

		if ($$self.$$.dirty[0] & /*xPaneRange*/ 4194304 | $$self.$$.dirty[1] & /*xLowerBound, xUpperBound*/ 3) {
			$$invalidate(22, xPaneRange = vec2.set(xPaneRange, xLowerBound, xUpperBound));
		}

		if ($$self.$$.dirty[0] & /*ySpan*/ 1073741824) {
			$$invalidate(29, yStep = Math.pow(base, Math.round(Math.log10(ySpan) / Math.log10(base))));
		}

		if ($$self.$$.dirty[0] & /*min, yStep*/ 536903680) {
			$$invalidate(28, yLowerBound = Math.floor(min[0] / yStep) * yStep);
		}

		if ($$self.$$.dirty[0] & /*max, yStep*/ 536936448) {
			$$invalidate(27, yUpperBound = Math.ceil(max[0] / yStep) * yStep);
		}

		if ($$self.$$.dirty[0] & /*yLowerBound, yUpperBound, yStep*/ 939524096) {
			$$invalidate(21, yPanes = range(yLowerBound, yUpperBound, yStep).iter().map(yMin => vec2.fromValues(yMin, yMin + yStep)).toArray());
		}

		if ($$self.$$.dirty[0] & /*yPaneRange, yLowerBound, yUpperBound*/ 411041792) {
			$$invalidate(23, yPaneRange = vec2.set(yPaneRange, yLowerBound, yUpperBound));
		}

		if ($$self.$$.dirty[0] & /*xPanes, yPanes, xPaneRange, yPaneRange*/ 15728640) {
			panesContext.set({ xPanes, yPanes, xPaneRange, yPaneRange });
		}

		if ($$self.$$.dirty[0] & /*min, max, actualWidth, actualHeight*/ 98316) {
			coordinateContext.set({
				min,
				max,
				width: actualWidth,
				height: actualHeight
			});
		}

		if ($$self.$$.dirty[0] & /*zoomAmount, scaleX, scaleY, span, pixelMatrix, inversePixelMatrix, cssScale*/ 118366208) {
			scaleContext.set({
				zoomAmount,
				scaleX,
				scaleY,
				span,
				pixelMatrix,
				inversePixelMatrix,
				cssScale
			});
		}

		if ($$self.$$.dirty[0] & /*mapX, mapY*/ 48) {
			mapContext.set({ mapX, mapY });
		}
	};

	return [
		width,
		pan,
		actualWidth,
		actualHeight,
		mapY,
		mapX,
		element,
		desiredCssHeight,
		desiredCssWidth,
		xAxisExtent,
		yAxisExtent,
		height,
		zoom,
		zoomAmount,
		offset,
		min,
		max,
		span,
		pixelMatrix,
		inversePixelMatrix,
		xPanes,
		yPanes,
		xPaneRange,
		yPaneRange,
		cssScale,
		scaleY,
		scaleX,
		yUpperBound,
		yLowerBound,
		yStep,
		ySpan,
		xUpperBound,
		xLowerBound,
		xStep,
		xSpan,
		unscaleY,
		unscaleX,
		$$scope,
		slots,
		div_binding,
		div_elementresize_handler
	];
}

class VisualMath extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				width: 0,
				height: 11,
				pan: 1,
				zoom: 12,
				xAxisExtent: 9,
				yAxisExtent: 10
			},
			null,
			[-1, -1]
		);
	}
}

export { CartesianCoordinates, Circle, Ellipse, GridPattern, MovablePoint, Point, PointAngle, PointSlope, ThroughPoints, VisualMath, XLabels, YLabels, getCoordinateContext, getMapContext, getPanesContext, getScaleContext, snappedRange };
